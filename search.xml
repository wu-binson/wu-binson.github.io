<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阅读的四个层次</title>
    <url>/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/How-to-Read-A-Book/</url>
    <content><![CDATA[<p>虽然我们经常阅读，但不一定懂得如何高效地阅读。大多数人的阅读过程仅仅是一种<strong>消极式阅读</strong>(Passive Reading)，无法充分消化成自己的知识。《<a href="https://book.douban.com/subject/1383525//" target="_blank" rel="noopener">How to Read a Book</a>》教导我们如何阅读。</p>
<a id="more"></a>
<p>就阅读目的来说，可分成Reading for Information和Reading for Understanding。前者以获取资讯为主要目的，可以是消遣式阅读，后者则是为了理解，相对前者是一种重量级的阅读，需要消耗更多的精力时间。本书教导的阅读技巧更多是为了后者服务的。</p>
<p>就阅读的深度来说，本书将阅读分为了四个层次：基础阅读(Elementary Reading)，检视阅读(Inspectional Reading)，分析阅读(Analytical Reading)，主题阅读(Syntoptical Reading)。</p>
<p><strong>基础阅读</strong>是最基础的阅读层次，这层出了问题，会造成很大程度的阅读困难和理解困难。比如，不熟练英文阅读的人去读一些英文原版书籍，经常发现有些词汇不懂，阅读速度很慢，甚至根本读不下去，便是这层的问题。如果是母语阅读，一般来说，这层涉及到的词汇积累或者简单的速度技巧在小时侯便学习到，这里不详述。</p>
<p><strong>检视阅读</strong>强调在有限时间内完成系统性的略读。这个层次的价值经常被大家忽略，个人认为检视阅读有两个最主要的目的: 1. 在有限时间内决定这本书值不值得花时间读。因为人的时间精力是有限的，阅读层次越往后消耗的时间精力资源越多。2. 得出书籍的大体脉络。大体脉络就像一张地图，让读者知道自己处于一个什么样的位置，亦相当于有了树的主干，在后面的分析阅读再在主干的基础上完善细节。</p>
<p>检视阅读可通过系统性地翻阅和粗浅的略读进行。前者主要着重看书的目录，每章每小节的标题，还有随便翻翻，粗看下一些段落。后者则提倡略读一遍书籍，碰到不会的词汇或者暂时不能理解的地方也不要随便停下来。</p>
<p><strong>分析阅读</strong>则是我们平时说的精读。这层次的主要目标就是为了理解。分析阅读要求我们回答书籍的主要观点，论证，论据等，以及读者对这些观点持有的态度，是支持还是中立。读者需要不停地问问题和尝试去回答问题，让自己消化书本的内容，利于形成自己的见解。</p>
<p><strong>主题阅读</strong>是最花精力的阅读层次，也可能是收获最多的活动。它提倡读者去阅读跟这本书主题相关的一系列书籍，然后比较它们的内容和观点等。</p>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>阅读 读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>运动改造大脑</title>
    <url>/brain/%E8%BF%90%E5%8A%A8%E6%94%B9%E9%80%A0%E5%A4%A7%E8%84%91/</url>
    <content><![CDATA[<h3 id="运动可以锻炼，改善，重塑大脑。"><a href="#运动可以锻炼，改善，重塑大脑。" class="headerlink" title="运动可以锻炼，改善，重塑大脑。"></a>运动可以锻炼，改善，重塑大脑。</h3><p>按《<a href="https://book.douban.com/subject/25755874/" target="_blank" rel="noopener">运动改造大脑</a>》中所述，运动对大脑的良性影响主要分为以下几种：</p>
<ol>
<li>改善记忆，专注和认知灵活性等在内的一些列认知功能。</li>
<li>提高压力阈值，释放压力。</li>
<li>改善焦虑抑郁情绪。剧烈的运动才能降低对焦虑的敏感度。</li>
<li>戒瘾。</li>
<li>抗衰老。<a id="more"></a>

</li>
</ol>
<p>即使意识到运动对大脑的好处，但付诸行动更为重要，我们需要从三方面制订运动计划：</p>
<ol>
<li>有氧能力。在一定强度和时间下的有氧运动，持之以恒后可得到改善大脑所必需的要素。</li>
<li>力量。主要为了增强骨骼。</li>
<li>平衡能力和柔韧性。这些运动一般需要一定的技巧性，有氧运动和复杂活动互补，对大脑产生不同的益处。这两者结合，往往会让我们收益更多。</li>
</ol>
<h3 id="训练时长和强度"><a href="#训练时长和强度" class="headerlink" title="训练时长和强度"></a>训练时长和强度</h3><p>美国疾控中心建议，每周至少五天进行30分钟中等强度的有氧运动。本书建议，最大运动量应该是每周6天进行45分钟至1小时有氧运动，4天进行1小时左右的中等强度运动，另外两天则是45分钟左右高强度运动。</p>
<h3 id="私人运动工具箱-现阶段-："><a href="#私人运动工具箱-现阶段-：" class="headerlink" title="私人运动工具箱(现阶段)："></a>私人运动工具箱(现阶段)：</h3><ol>
<li>步行(低强度): 即兴去一个地方，不用地图游玩，达到最大心率55%-65%，每次一小时。值得一说的是，不能忽视步行的作用。</li>
<li>慢跑(中等强度): 达到最大心率65%-75%。</li>
<li>跑步(高强度):达到最大心率75%-90%</li>
<li>爬山(高强度)</li>
<li>乒乓球: 技巧性兼兴趣性运动</li>
<li>跳舞(待): 技巧性运动，可配合体感游戏机</li>
<li>格斗术(待):技巧性运动，可配合体感游戏机</li>
<li>重量训练: 深蹲，俯卧撑，每天几组</li>
</ol>
<h3 id="运动后的饮食"><a href="#运动后的饮食" class="headerlink" title="运动后的饮食"></a>运动后的饮食</h3><p>(略)
值得一提的是，从鱼类获得的Omega-3脂肪酸对大脑有很大的帮助，比如减少认知衰退速度。</p>
]]></content>
      <categories>
        <category>大脑</category>
      </categories>
      <tags>
        <tag>运动 读书笔记 运动改造大脑</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Solve It</title>
    <url>/math/how_to_solve_it/</url>
    <content><![CDATA[<h1 id="Outline-of-Steps"><a href="#Outline-of-Steps" class="headerlink" title="Outline of Steps"></a>Outline of Steps</h1><p>What the questions and suggestions bellowing can do is to “<strong>keep the ball rolling</strong>“?</p>
<h2 id="Understanding-the-problem"><a href="#Understanding-the-problem" class="headerlink" title="Understanding the problem"></a>Understanding the problem</h2><p>First of all, begin with understanding the problem <strong>as a whole</strong>, considering the <strong>principal parts</strong> of the problem.</p>
<ol>
<li><a href="#What-is-the-unknown">What is the <strong>unknown</strong></a>?</li>
<li>What is the <strong>data</strong>?</li>
<li><a href="#What-is-the-condition">What is the <strong>condition</strong></a>? Is the condition <strong><em>sufficient to determine the unknown</em></strong>? Or is it <strong><em>insufficient</em></strong>? Or <strong><em>redundant</em></strong>? Or <strong><em>contradictory</em></strong>?</li>
<li>Draw a figure and introduce a suitable <a href="#Notation">notation</a> if it is necessary.</li>
</ol>
<a id="more"></a>
<p> <strong>Go into the detail</strong> and decompose the problem gradually, <em>but not further than we need do.</em></p>
<ol start="5">
<li><a href="#Separate-the-various-parts-of-the-condition">Separate the various parts of the condition</a>.</li>
</ol>
<h2 id="Devise-a-Plan"><a href="#Devise-a-Plan" class="headerlink" title="Devise a Plan"></a>Devise a Plan</h2><p>Find the <strong>connection between the unknown and the data</strong>. You might consider <a href="#Auxiliary-Problems">auxiliary problems</a> if an immediate connection cannot be found.</p>
<p><em>Good ideas are based on past experience and formerly acquired knowledge.</em></p>
<ol>
<li><strong>Have you seen it before</strong>? Or have you seen the same problem in a slightly different form?</li>
<li><strong>Do you know a related problem</strong>? Do you know a theorem could be useful?</li>
<li><strong>Look at the unknown!</strong> Try to think of a familiar problem having the same or a similar unknown.</li>
<li><strong>If there is a problem related to yours and solved before</strong>. Could you use it? Its result or its method? Should you introduce some <a href="#Auxiliary-Elements">auxiliary elements</a> in order to make its use possible?</li>
</ol>
<p><em>If the foregoing questions do not work</em></p>
<ol start="5">
<li>Could you <strong>restate the problem</strong>? Could you restate it still differently?<ol>
<li><a href="#Definition">Go back to definitions</a>.</li>
<li>These questions aim at suitable <a href="#variation-of-the-problem">variation of the problem</a>.</li>
</ol>
</li>
<li>If you cannot solve the proposed problem, try to <strong>solve first some related problem</strong>.<ol>
<li>Could you imagine a more <a href="#Generalization">general</a> problem?</li>
<li>A more <a href="#Specialization">special</a> problem?</li>
<li>An <strong><a href="#Analogy">analogous</a></strong> problem?</li>
<li><a href="#condition-variation">Keep only a part of the condition, drop the other part</a>, how far is the unknown then determined, how can it vary?</li>
<li><a href="#Could-you-derive-something-useful-from-data">Could you derive something useful from the data?</a> <a href="#introduce-new-unknown">[1]</a></li>
<li>Could you think of other data appropriate to determine the unknown? <a href="#keep-the-unknown">[2]</a></li>
<li>Could you <strong>change the unknown or the data</strong> <a href="#change-both-unknown-and-data">[3]</a>, or both if necessary, so that the new unknown and the new data are nearer to each other?</li>
</ol>
</li>
</ol>
<p>We may stray so far from our original problem that we are in danger of losing it altogether. <em>The following question may bring us back.</em></p>
<ol start="7">
<li>Did you use <strong>all the data</strong>?</li>
<li>Did you <strong>use the whole condition</strong>?</li>
</ol>
<h2 id="Carry-Out-the-Plan"><a href="#Carry-Out-the-Plan" class="headerlink" title="Carry Out the Plan"></a>Carry Out the Plan</h2><p><strong>Check each step</strong></p>
<p><strong>When to Start</strong>: When you feel sure of your <strong><em>grasp of the main connection</em></strong> and you feel confident that you can <strong><em>supply the minor details</em></strong> that mat be wanting.</p>
<ol>
<li>Carrying out your plan of the solution <strong>check each step</strong>.</li>
<li>Can you <strong>see clearly</strong> that the step is correctly?</li>
<li>Can you <strong>prove</strong> that it is correct?</li>
</ol>
<h2 id="Looking-Back"><a href="#Looking-Back" class="headerlink" title="Looking Back"></a>Looking Back</h2><ol>
<li><a href="#Can-you-check-the-result"><strong>Can you check the result?</strong></a> <a href="#Can-you-check-the-argument">Can you check the argument?</a><ol>
<li>Have you taken into account all <strong>essential notions</strong> involved in the problem? How did you use this notion? Did you use its meaning, its definition?</li>
<li>Did you use essential facts, known theorems about it?</li>
<li>Have you used all the data?</li>
</ol>
</li>
<li>Can you derive the result differently? Can you see it at a glance?</li>
<li><a href="#Can-you-use-the-result">Can you use the result</a>, or the method, for some other problem?</li>
</ol>
<h1 id="Details-of-Steps"><a href="#Details-of-Steps" class="headerlink" title="Details of Steps"></a>Details of Steps</h1><h2 id="What-is-the-unknown"><a href="#What-is-the-unknown" class="headerlink" title="What is the unknown"></a>What is the unknown</h2><p>What is the unknown? what are the data? What is the condition?</p>
<ol>
<li>Check our own understanding of the problem.</li>
<li>The question direct our attention to the <strong>principal parts</strong> of a problem.</li>
</ol>
<h2 id="What-is-the-condition"><a href="#What-is-the-condition" class="headerlink" title="What is the condition"></a>What is the condition</h2><p><strong>Condition links the unknowns of a “problem to find” to the data</strong>.</p>
<h3 id="The-condition-to-determine-the-unknowns"><a href="#The-condition-to-determine-the-unknowns" class="headerlink" title="The condition to determine the unknowns"></a>The condition to determine the unknowns</h3><ol>
<li>If the condition is expressed by <em>more</em> linear equations than there are unknowns, it is either <strong><em>redundant</em></strong> or <strong><em>contradictory</em></strong>.</li>
<li>If the condition is expressed by less linear equations than there are unknowns, it’s <strong><em>insufficient</em></strong> to determine the unknowns.</li>
<li>If the condition is expressed by just as many equations as there are unknowns it is usually just <strong><em>sufficient</em></strong> to determine the unknowns, but may be, in exceptional cases, <strong><em>contradictory</em></strong> or <strong><em>insufficient</em></strong>.</li>
</ol>
<h3 id="Separate-the-various-parts-of-the-condition"><a href="#Separate-the-various-parts-of-the-condition" class="headerlink" title="Separate the various parts of the condition"></a>Separate the various parts of the condition</h3><p><a href="#Decomposing">Using decomposing method</a>.</p>
<h2 id="Could-you-derive-something-useful-from-data"><a href="#Could-you-derive-something-useful-from-data" class="headerlink" title="Could you derive something useful from data"></a>Could you derive something useful from data</h2><ol>
<li>It appears that starting the reasoning <strong>from the unknown</strong> is usually preferable. Yet the alternative start, <strong>from the data</strong>, also has chances to success.</li>
<li><strong>Example</strong> (Page 73): <em>We are given three points $A,B$, and $C$. Draw a line through $A$ which passes between $B$ and $C$ and is at equal distance from $B$ and $C$</em>.</li>
<li>Did you use all the data?</li>
</ol>
<h2 id="Carry-Out"><a href="#Carry-Out" class="headerlink" title="Carry Out"></a>Carry Out</h2><ol>
<li>When <em>devising the plan of the solution</em>, anything is right that leads to the right idea. We should not be too afraid of merely plausible, heuristic reasoning. When <em>carrying out the plan</em>, and then we should accept only conclusive, strict arguments.</li>
<li>The more painstakingly we check our steps when carrying out the plan, the more freely we may use heuristic reasoning when devising it.</li>
<li>It’s not reasonable to check minor details before we have good reasons to believe that the major steps of the argument are sound.</li>
<li>Euclid’s manner of exposition, progressing relentlessly from the data to the unknown and from the hypothesis to the conclusion,
is prefect for <em>checking the argument</em> in detail but far from being prefect for <em>making understandable the main line of the argument</em>.</li>
</ol>
<h3 id="Intuitive-Insight-and-Formal-Proof"><a href="#Intuitive-Insight-and-Formal-Proof" class="headerlink" title="Intuitive Insight and Formal Proof"></a>Intuitive Insight and Formal Proof</h3><ol>
<li>Intuitive insight and formal proof are two different ways of perceiving the truth.</li>
<li>Intuitive insight may rush far ahead of formal proof. Sometimes, however, formal manipulation of logical rules and algebraic formulas may get far ahead of intuition.</li>
</ol>
<h2 id="Can-you-check-the-result"><a href="#Can-you-check-the-result" class="headerlink" title="Can you check the result"></a>Can you check the result</h2><ol>
<li><strong><em>Numerical results</em></strong> of mathematical problems can be tested by comparing them to <strong><em>observed numbers</em></strong>, or to a <strong><em>commonsense estimate</em></strong> of observed numbers.</li>
<li>Problems <em>in letters</em> are susceptible of more, and more interesting, tests than problems <em>in numbers</em>.</li>
<li><strong>Test by variation of data</strong>. For example, how would the unknown change as one of the data increases?</li>
<li><strong>Test by specialization. including the extreme cases</strong>.</li>
<li>Test by dimension.</li>
</ol>
<h3 id="Can-you-check-the-argument"><a href="#Can-you-check-the-argument" class="headerlink" title="Can you check the argument"></a>Can you check the argument</h3><ol>
<li>Avoid mere repetition.<ol>
<li>Mere repetition is apt to become boring, uninstructive, a stain on the attention.</li>
<li>Where we stumbled once, there we are likely stumble again if the circumstances are the same as before.</li>
</ol>
</li>
<li>If we feel that it is necessary to go again through the whole argument step by step, we should at least change the order of the steps, or their grouping, to introduce some variation.</li>
</ol>
<h2 id="Can-you-use-the-result"><a href="#Can-you-use-the-result" class="headerlink" title="Can you use the result"></a>Can you use the result</h2><p><span id="variation-of-the-problem">Vary the problem</span></p>
<ol>
<li>Basic means:<ol>
<li>Generalization</li>
<li>Specialization</li>
<li>Analogy</li>
<li>Decomposing</li>
<li>Recombining</li>
</ol>
</li>
<li>Regard the original unknown as given and one of the original data as unknown.</li>
<li>Derive new problems from a proposed one by considering certain of its elements as variable.</li>
</ol>
<h1 id="Methods-and-Tools"><a href="#Methods-and-Tools" class="headerlink" title="Methods and Tools"></a>Methods and Tools</h1><h2 id="Analogy"><a href="#Analogy" class="headerlink" title="Analogy"></a>Analogy</h2><p>Analogy can reach <strong>the level of mathematical precision</strong>.</p>
<ol>
<li>Using the <strong>method</strong> of the simpler analogous problem.</li>
<li>Using the <strong>result</strong> of the simpler analogous problem.</li>
<li><strong><em>The solution of the analogous problem might not be immediately used for our original problem</em></strong>. And it may be worth while to reconsider the solution, to <strong><em>vary and to modify</em></strong> it till, after having tried various forms of the solution, we find eventually one that can be extended to our original problem.</li>
<li><strong>Inference by analogy</strong>: some plausible forecasts are often based on analogy.</li>
<li><strong>Example</strong> (Page 38): <em>Find the center of gravity of a homogeneous tetrahedron</em> .</li>
</ol>
<h2 id="Auxiliary-Elements"><a href="#Auxiliary-Elements" class="headerlink" title="Auxiliary Elements"></a>Auxiliary Elements</h2><ol>
<li>An element that we introduce in the hope that it will further the solution is called an <strong>auxiliary element</strong>, including <em>auxiliary line</em>,  <em>auxiliary unknown</em>, <em>auxiliary theorem</em>, etc.</li>
<li><strong>Reasons for introducing auxiliary elements</strong>: trying to use known results and <a href="#Definition">going back to definitions</a>, etc.</li>
<li><strong>Example</strong> (Page 48): <em>Construct a triangle, being given one angle, the altitude drawn from the vertex of the given angle, and the perimeter of the triangle</em>.</li>
</ol>
<h2 id="Auxiliary-Problems"><a href="#Auxiliary-Problems" class="headerlink" title="Auxiliary Problems"></a>Auxiliary Problems</h2><ol>
<li>See <a href="#Auxiliary-Elements">Auxiliary Elements</a></li>
<li><strong>Risk</strong>: If our investigation of the auxiliary problem fails, the time and effort we devoted to it may be lost.</li>
<li><strong>How to find one</strong>.<ol>
<li>There is <strong><em>no infallible method</em></strong>.</li>
<li>There are, however, questions and suggestions which are frequently helpful, as <strong>look at the unknown</strong>.</li>
<li>We are often let to useful auxiliary problem by <strong><a href="#variation-of-the-problem">variation of the problem</a></strong>.</li>
</ol>
</li>
<li><strong>Equivalent problems</strong>. The passage from the original problem to the auxiliary problem is called <strong>convertible reduction</strong> if these two problems are equivalent.</li>
<li><strong>Chains of equivalent auxiliary problems</strong>. We must check carefully the nature of each newly introduced condition: Is it equivalent to the original condition?</li>
<li><strong>Unilateral reduction</strong>: the step passing from a problem either to a <em>more ambitious</em> or to a <em>less ambitious</em> auxiliary problem.<ol>
<li>It’s <strong><em>more risky</em></strong> than a convertible reduction.</li>
<li><a href="#Specialization"><strong>Specialization</strong></a>: from more ambitious to less ambitious.</li>
<li><a href="#Generalization"><strong>Generalization</strong></a>: from less ambitious to more ambitious.</li>
</ol>
</li>
</ol>
<h2 id="Decomposing-and-Recombining"><a href="#Decomposing-and-Recombining" class="headerlink" title="Decomposing and Recombining"></a>Decomposing and Recombining</h2><h3 id="Decomposing"><a href="#Decomposing" class="headerlink" title="Decomposing"></a>Decomposing</h3><p>When decomposing the problem, it may be necessary to <a href="#Definition">go back to the definition</a> of a certain term, to <strong>introduce new elements</strong> involved by the definition, and to <strong>examine the elements</strong> so introduced.</p>
<h3 id="Recombining"><a href="#Recombining" class="headerlink" title="Recombining"></a>Recombining</h3><p>After having decomposed the problem, we try to recombine its elements in some newer manner. The following are certain <strong>usual</strong> and relatively <strong>simple</strong> sorts of combination:</p>
<ol>
<li><span id="keep-the-unknown"><strong>Keep the unknown and change the rest</strong></span>(the data and the condition).<ol>
<li>Change as little as feasible.</li>
<li>Omit something without adding anything, ie. <span id="condition-variation">condition</span>.</li>
</ol>
</li>
<li><strong>Keep the data and change the rest</strong>(the unknown and the condition).<ol>
<li><span id="introduce-new-unknown">Try to introduce some <strong>useful</strong> and <strong>more accessible</strong> new unknown.</li>
</ol>
</li>
<li><span id="change-both-unknown-and-data"><strong>Change both unknown and data</strong>.</span><ol>
<li>More risky</li>
<li>An interesting way of change both the unknown and the data, is interchanging the unknown and one of the data.</li>
<li><strong>Example</strong> （Page 80）: <em>Construct a triangle, being given a side $a$, the altitude $h$ perpendicular to $a$, and the angle $\alpha$ opposite to $a$</em>.</li>
</ol>
</li>
</ol>
<h2 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h2><p>The more general problem my be easier to solve.</p>
<h2 id="Specialization"><a href="#Specialization" class="headerlink" title="Specialization"></a>Specialization</h2><ol>
<li><strong>Example</strong> (Page 190): <em>In a triangle, let $r$ be the radius of the inscribed circle, $R$ the radius of the circumscribed circle, and $H$ the longest altitude. Then</em>
$$
r+R \leq H
$$</li>
<li><strong>Extreme cases</strong> are particularly instructive.</li>
<li><strong>Example</strong> (Page 193): <em>Given the speeds of two ships and their position at a certain moment; each ship steers a rectilinear course with constant speed. Find the distance of the two ships when they are nearest to each other.</em></li>
</ol>
<h2 id="Heuristic-Reasoning"><a href="#Heuristic-Reasoning" class="headerlink" title="Heuristic Reasoning"></a>Heuristic Reasoning</h2><ol>
<li>Heuristic aims at <strong>generality</strong>.</li>
<li>Heuristic reasoning is reasoning not regarded as final and strict but as provisional and plausible only, whose purpose is discover the solution of the present problem.</li>
<li><strong>Heuristic reasoning is often based on induction, or on analogy.</strong></li>
</ol>
<h2 id="Induction-and-Mathematical-Induction"><a href="#Induction-and-Mathematical-Induction" class="headerlink" title="Induction and Mathematical Induction"></a>Induction and Mathematical Induction</h2><h2 id="Reduction-to-an-absurdity"><a href="#Reduction-to-an-absurdity" class="headerlink" title="Reduction to an absurdity"></a>Reduction to an absurdity</h2><p>Reduction to an absurdity shows the falsity of an assumption by deriving from it a manifest absurdity.</p>
<h2 id="Indirect-Proof"><a href="#Indirect-Proof" class="headerlink" title="Indirect Proof"></a>Indirect Proof</h2><p>Indirect proof establishes the truth of an assumption by showing the falsity of the opposite assumption.</p>
<h2 id="Working-Backwards"><a href="#Working-Backwards" class="headerlink" title="Working Backwards"></a>Working Backwards</h2><p><strong>Example</strong> (Page 226): <em>How can you bring up from the river exactly six quarts of water when you have only two containers, a four quart pail and a nice quart pail, to measure with</em>.</p>
<h2 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h2><p>The language of mathematical symbols and figures assist the mind.</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><ol>
<li>The <em>technical terms</em> in mathematics are of two kinds.<ol>
<li>Some are accepted as primitive terms and are not defined.</li>
<li>Others’ meaning is stated in primitive terms and in formerly defined derived terms.</li>
</ol>
</li>
<li><strong>Elimination of technical terms</strong>.<br> By going back to the definition of a technical term, we get rid of the term but introduce new elements and new relations instead.</li>
<li>We must know, at least, the definition but is better to know about some <strong>theorems</strong>.</li>
<li>A technical term in mathematics might have <em>several definitions</em>.<ol>
<li>When going back to its definitions, <strong>Much may depend in such a case on choosing the definition that fits the case.</strong></li>
<li><em>See the example of Archimedes to find the area of the surface of the sphere</em>. (Page 90)</li>
</ol>
</li>
</ol>
<h2 id="Symmetry"><a href="#Symmetry" class="headerlink" title="Symmetry"></a>Symmetry</h2><p>A whole is termed symmetry if it has <strong>interchangeable parts</strong>.</p>
<ol>
<li>If a problem is symmetry in some ways we may derive some profits from <strong>noticing its interchangeable parts</strong> and it often pays to treat those parts which play the same role <strong>in the same fashion</strong>.</li>
<li>Try to treat <strong>symmetrically</strong> what is symmetrical. and do not destroy any natural symmetry.</li>
</ol>
<h1 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h1><h2 id="Determination-hope-success"><a href="#Determination-hope-success" class="headerlink" title="Determination, hope, success"></a>Determination, hope, success</h2><ol>
<li>Determination fluctuates with hope and hopelessness with satisfaction and disappointment.</li>
<li>Scientists should have some hope to start with ,and some success to go on.</li>
</ol>
<h2 id="Sign-of-Progress"><a href="#Sign-of-Progress" class="headerlink" title="Sign of Progress"></a>Sign of Progress</h2><p>Always follow your inspiration-with a grain of doubt.</p>
<h2 id="Practical-Problems"><a href="#Practical-Problems" class="headerlink" title="Practical Problems"></a>Practical Problems</h2><ol>
<li>Practical problems are different in various respects from purely Mathematical problems. yet the principal motives and procedures of the solution are essentially the same.</li>
<li>Example (Page 149):<em>The construction of a dam across a river</em>.</li>
</ol>
<h2 id="Problem-to-Prove"><a href="#Problem-to-Prove" class="headerlink" title="Problem to Prove"></a>Problem to Prove</h2><h3 id="Principal-Parts"><a href="#Principal-Parts" class="headerlink" title="Principal Parts"></a>Principal Parts</h3><ol>
<li>The principal parts of a “<em>problem to find</em>“ are the <em>unknown</em>, the <em>data</em>, and the <em>condition</em>.</li>
<li>The principal parts of a “<em>problem to prove</em>“ are the <em>hypothesis</em> and the <em>conclusion</em>.</li>
</ol>
<h3 id="Steps-for-“Problem-to-Prove”"><a href="#Steps-for-“Problem-to-Prove”" class="headerlink" title="Steps for “Problem to Prove”"></a>Steps for “Problem to Prove”</h3><p>In Steps of “problem to find”</p>
<ol>
<li>Replace unknown with conclusion</li>
<li>Replace data and conclusion with hypothesis.</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>解题方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>学会提问(三)之理由是什么</title>
    <url>/thinking/critical_thinking/reason/</url>
    <content><![CDATA[<p>理由是用来支撑结论的重要基石。想客观评价一个结论的价值，分析支撑它的理由是必不可少的步骤。当支撑这个结论的理由非常脆弱或不堪一击，那么表面看似多么有道理的结论都理应受到质疑。反之，即使我们暂时不认同某个结论，我们也要仔细琢磨它的理由。</p>
<a id="more"></a>
<h3 id="理由-结论-论证"><a href="#理由-结论-论证" class="headerlink" title="理由+结论=论证"></a>理由+结论=论证</h3><p>简单来讲，论证的过程就是用一个或多个想法来支撑另外一个想法的过程。它具备几个特性：</p>
<ul>
<li><strong>论证必有其目的</strong>。一般论证的目的是让我们相信它的结论或者按照它的建议去完成某一件事情。</li>
<li><strong>论证质量有高低之分</strong>。</li>
<li><strong>论证有两个明显的必要构成成分：结论和理由</strong>。如果我们找不到一篇文章里的这两个部分，就失去客观评价这论证的机会。</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>①中学阶段的男篮和男足常常一统周五晚上的节目单，应不应该是这个样子？②这些比赛对中学经历的人而言意义非凡，但也不至于为此牺牲掉其他所有运动项目。③仅仅因为他们有悠久传统并不意味着这种模式就一定要世代因循。
④周五晚上腾出时间观看比赛对大多数父母和球迷而言自然要容易得多。⑤因此，周五晚上他们亲自来看男篮和男足比赛自然也很容易。
⑥那么女子篮球队或游泳队又怎么办呢？⑦她们的比赛不应该总是被安排在周一到周五下午和晚上举行。⑧她们的家人经常不能腾出时间来观看她们的比赛，因为大多数父母下午都要上班。⑨那些参加这些“二流”体育运动的学生根本没有得到聚光灯的平等关注。⑩男篮和男足的日程表应该做出相应改变，为其他体育活动腾出一点空间。</p>
<p><strong>论题</strong>：中学阶段的周五晚上节目单应不应该清一色是男篮或男足？</p>
<p><strong>结论</strong>：男篮和男足的日程表应该做出相应改变，为其他体育活动腾出一点空间。</p>
<p><strong>理由</strong>：</p>
<ol>
<li>虽然男篮和男足有悠久的传统，但不至于牺牲掉其他所有项目。
②③句</li>
<li>其他项目被迫安排到其他不利于观看的时间段，受到了不平等的对待 
⑦⑧⑨句</li>
</ol>
]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>critical thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>学会提问(一)之批判性提问技能</title>
    <url>/thinking/critical_thinking/summary/</url>
    <content><![CDATA[<h3 id="批判性提问技能的适用场景和重要性"><a href="#批判性提问技能的适用场景和重要性" class="headerlink" title="批判性提问技能的适用场景和重要性"></a>批判性提问技能的适用场景和重要性</h3><p>批判性提问技能是一项非常重要的技能，它的适用范围非常广，几乎可以运用到生活的各个角落。</p>
<p>随着互联网和物联网对现代文明的进一步渗透，以及近年来自媒体的兴起，每个上网的人都可以发出自己的声音。这些信息的质量有高有低，这个时候理性地分辨出哪些是虚假信息，哪些言论存在漏洞，哪些是经得起推敲的观点，是非常重要的。而批判性提问技能可以帮助我们在信息洪流里站稳脚跟。</p>
<a id="more"></a>
<p>在与互联网不相关的地方，比如学习和阅读，批判性提问也能够让我们比较充分地参与到这个过程中，能够帮助我们集中精神。当我们针对书籍材料的观点提出一些问题并尝试着去思考时，我们将可以对这些材料有着更深入的理解，这过程还会附带成就感。</p>
<p>这种技能还适用另外一个重要的场景，就是科学研究的过程。科学研究的本质就是站在前人的理论上提出自己的理论（<em>理论是特殊的观点</em>）。科学理论几乎都有着自身时代的局限性，比如牛顿力学只能解释宏观层面的现象。用批判性思维看待科学理论有助于我们提出新的，更先进的理论。
除了上面提到的，还有很多其它的场景，所以这种技能的重要性便不言而喻了。结合上面的场景，个人认为，它的重要性主要体现在以下三大方面：</p>
<ol>
<li><strong>帮助你选择性过滤掉来自外界的观点。</strong>在充分思考后，你可以自主选择地支持一些观点，这时的你应该可以说出自己支持这些观点的理由，甚至还可以找到瑕疵之处。同时，你可能会不赞成一些观点，在这过程中顺便能找到反驳的理由。</li>
<li><strong>除了过滤外界的观点，批判性提问法能让我们审视自己的观点。</strong>在批判性看待自己的观点后，我们可以更加肯定或者修正甚至否定之前的观点。提出一个由许多小观点组成的大观点，或者写文章等类似活动类似于程序员写各种软件系统，程序员都知道，几乎很少有不存在漏洞的完美系统，而且系统越大出漏洞的概率就越大，所以我们能做的只是尽可能地填上漏洞。而批判提问法帮助我们发现自己的文章或者观点里面的漏洞所在，及时修补上。</li>
<li>如上面所说，<strong>批判性提问技能帮助我们充分参与到学习，阅读，各种会议等活动中</strong>。另外，我们可以凭借提出的关键问题顺藤摸瓜，搜寻到某类问题的答案。</li>
</ol>
<h3 id="何为批判性提问和批判性思维"><a href="#何为批判性提问和批判性思维" class="headerlink" title="何为批判性提问和批判性思维"></a>何为批判性提问和批判性思维</h3><p>这里先解释下批判性提问(critical-questioning)，批判性提问这个术语由两个部分组成，分别是批判性思维和提问。提问的目的自然是提出关键问题，而批判性思维就是为了这个目标所服务。至于批判性思维，书中给出了这样的解释，它主要涵盖了以下几个方面：</p>
<ul>
<li>有一套相互关联、环环相扣的关键问题的意识。</li>
<li>恰如其分地提出和回答关键问题的能力。</li>
<li>积极主动地利用关键问题的强烈愿望。</li>
</ul>
<p>书的目的便是激发读者朝这三个方面全面发展。
从批判性思维用途的角度出发，可以将批判性思维分成<strong>弱势批判性思维</strong>和<strong>强势批判性思维</strong>。其中弱势批判性思维的目的是抵制和驳倒与你观点不同的论述，并不关心自己的观点能否更接近真理。弱势批判性思维最大的问题在于尽力维护的观点可能一开始就是错的。强势批判性思维的目的恰恰相反，它要求我们一视同仁地对待别人和自己的观点。</p>
<h3 id="批判性提问的可操作步骤"><a href="#批判性提问的可操作步骤" class="headerlink" title="批判性提问的可操作步骤"></a>批判性提问的可操作步骤</h3><h4 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h4><ol>
<li><a href="https://wubinson.github.io/note/critical_thinking/thesis/" target="_blank" rel="noopener">论题和结论是什么</a></li>
<li><a href="https://wubinson.github.io/note/critical_thinking/reason/" target="_blank" rel="noopener">理由是什么</a></li>
<li>哪些词语不明确</li>
<li>什么是价值观假设和描述性假设</li>
<li>推理过程有没有谬误</li>
<li>证据的效力如何</li>
<li>有没有替代原因</li>
<li>数据有没有欺骗性</li>
<li>有什么重要信息被省略了</li>
<li>能得出哪些合理的结论</li>
</ol>
<p>上面的步骤暂时仅需要初步了解下，<strong>每一个步骤都是后面的章节</strong>，后面会详细讲解。</p>
<h4 id="勤加练习"><a href="#勤加练习" class="headerlink" title="勤加练习"></a>勤加练习</h4><p>只知道这种技能的存在却不会使用之仅仅比不知道概念强一点，想掌握技能需要大量的练习。除了书中每章节后面的练习题，生活中的各种观点都应该被视为我们潜在的练习题。</p>
<h3 id="两个重要的意识"><a href="#两个重要的意识" class="headerlink" title="两个重要的意识"></a>两个重要的意识</h3><h4 id="对话交流可以促进进步"><a href="#对话交流可以促进进步" class="headerlink" title="对话交流可以促进进步"></a>对话交流可以促进进步</h4><p>不要封堵住与别人交流对话的渠道，甚至需要我们主动去创造交流的机会。与别人的交流可以修正你的观点，即使你对自己的观点很有信心，即使对方看似各方面都不如你（<em>很多时候是错觉</em>）。</p>
<h4 id="你有没有可能是错的"><a href="#你有没有可能是错的" class="headerlink" title="你有没有可能是错的"></a>你有没有可能是错的</h4><p>在你对自己的观点很有自信，快要到”蔑视”其它观点的时候，都应该问问自己，你有没有可能是错的。很多程序员都有这样的经历：在开发复杂的软件系统的过程，许多躲藏在思维盲区的bug会不停地冲击他们的自以为是。而实现世界又是一个极其复杂的系统。</p>
<h3 id="批判性思维的弊端"><a href="#批判性思维的弊端" class="headerlink" title="批判性思维的弊端"></a>批判性思维的弊端</h3><p>批判性思维的好处很多，当然它也会有弊端。它比海绵思维需要更多的注意力，在使用批判性思维这个工具的时候，它会消耗掉使用者一定的精力。人的精力是有限的，所以<strong>我们应该将这个强大的工具使用在重要的场景</strong>。掌握起来不容易也算是这个工具的弊端之一。</p>
<p>还有就是，生活上很多观点有很多细节是不能证实或者不能证伪的，有部分是因为人类使用的语言系统的原因，比如“很多程序员喜欢写c”这句话，里面的“很多”是很模糊的，“很多”到底是多少，占了多大的比例，这些都是不得而知的。碰到这种情况，批判性思维会建议我们保持怀疑的态度，这也是一个追求真理的学者必须具备的素质。但生活里有些情况是需要快速决断的，比如一个领导者在重大决断前面对下属的犹豫时间越长，有时候给团队带来的危害会越严重（开始是精神层面的，后面可能导致团队瓦解），甚至会比做出错误决断还要严重。</p>
<h3 id="一个小问题——关于批判思维的思考对象"><a href="#一个小问题——关于批判思维的思考对象" class="headerlink" title="一个小问题——关于批判思维的思考对象"></a>一个小问题——关于批判思维的思考对象</h3><p>查阅了一些关于批判性思维的材料和定义，似乎没有个统一或者明确点的说法。<strong>个人更倾向认为，批判性思维这个工具剖析的对象是各种被假设或者逻辑支撑起来的观点（<em>因为观点都是人提出来的，所以都与人相关</em>），而不是自然界客观存在的事物。至少书中教导我们的批判性提问技能就是这种</strong>。这种技能是“提出关键问题”技能的子集，前者没有后者的范围广。比如，在科研面对一些自然现象，科学家会提出一些关于客观存在的事物的关键问题，来驱动自己的研究。批判性提问技能在这里是不适用的（看看本文3.1的步骤）,它适用的场景是当你面对别人的论文和理论的时候。虽然如此，它仍然是非常重要的工具，知道它的局限性可以让我们使用起来更加游刃有余。</p>
]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>critical thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>学会提问(二)之论题和结论</title>
    <url>/thinking/critical_thinking/thesis/</url>
    <content><![CDATA[<h3 id="论题的分类"><a href="#论题的分类" class="headerlink" title="论题的分类"></a>论题的分类</h3><p>论题是引起对话或者讨论的问题，是后续讨论的驱动力。它主要分成两大类：</p>
<a id="more"></a>
<p>1.<strong>描述性论题</strong>。这类论题讨论的是世界过去、现在、未来是什么样。它的例子如下：</p>
<ul>
<li>PHP是不是世界上最好的语言？</li>
<li>中国能不能取代美国成为世界第一？</li>
<li>上个好大学重要吗？</li>
<li>一般来讲，女生学习语言的能力是不是比男生强？</li>
</ul>
<p>2.<strong>规定性论题</strong>。这类论题讨论的是世界应该是什么样子的，什么是对的是什么错的，什么该有什么不该有。它的例子如下：</p>
<ul>
<li>应不应该鼓励大学生创业？</li>
<li>要不要和异地的网友谈恋爱？</li>
<li>选择高校应不应该将城市作为重要因素来考虑？</li>
<li>学校应不应该规范学生的穿着？</li>
</ul>
<p>有些文章的论题很容易看出，有些却非常隐晦，这时可以先找结论，再反推论题。很多时候，这两种论题总是成对紧密地出现。比如，一篇文章的标题是“晨练好还是晚练好”，最后的结论是晚练更有益，我们应该晚练（这不是我的结论）。只看标题我们知道题目是一个描述性命题，但看到结论我们可以知道文章暗含着规定性命题，也就是“我们应该晨练还是晚练”。这里的规定性论题的结论由描述性命题的结论很自然地推出。</p>
<h3 id="结论与纯观点"><a href="#结论与纯观点" class="headerlink" title="结论与纯观点"></a>结论与纯观点</h3><p>结论是逐步推断出来的，来源于推理。一个结论由其他证据或者观点支撑起来。没有证据支撑的断言不能算结论，只能称为纯观点。还有，例句、数据、定义、背景资料和证据这些东西不可能是结论。</p>
<h3 id="当我们自己写作的时候"><a href="#当我们自己写作的时候" class="headerlink" title="当我们自己写作的时候"></a>当我们自己写作的时候</h3><p>1 将论题的范围尽量缩小
2 引导读者得出你的结论</p>
]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>critical thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的机器级表示</title>
    <url>/IT/csapp/asm/</url>
    <content><![CDATA[<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p><font color="#ff0000"><strong>Intel</strong>使用术语表示16位数据类型。所以32位数被称为double word，同理，64位被称为quad word。</font></p>
<a id="more"></a>
<h3 id="整数寄存器和数据传送指令"><a href="#整数寄存器和数据传送指令" class="headerlink" title="整数寄存器和数据传送指令"></a>整数寄存器和数据传送指令</h3><p>·<img src="/img/books/csapp/chapter3/i-register.png" alt="整数寄存器">
·<img src="/img/books/csapp/chapter3/mov.png" alt="mov">
<font color="#ff0000">比较特别的是，当movl指令以寄存器作为目的，它会把寄存器的高4位字节设置为0.</font></p>
<p>以下两类数据移动指令，<strong>用于较小的源值复制到较大的目的寄存器的时候</strong>。
·<img src="/img/books/csapp/chapter3/movz.png" alt="movz">
·<img src="/img/books/csapp/chapter3/movs.png" alt="movs"></p>
<p>考虑到以下的指令:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">src_t</span> *sp;</span><br><span class="line"><span class="keyword">dest_t</span> *dp;</span><br><span class="line"></span><br><span class="line">*dp=(<span class="keyword">dest_t</span>)*sp;</span><br></pre></td></tr></table></figure>
<p>假设sp和dp的值分别存储在%rdi和%rsi的寄存器里，src_t是char，dest_t是unsigned。那么*dp=(dest_t)*sp;对应的汇编代码
是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movsbl (%rdi),%eax;</span><br><span class="line">movl %eax,(%rsi);</span><br></pre></td></tr></table></figure>
<h3 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h3><p><img src="/img/books/csapp/chapter3/arithmetic.png" alt="arithmetic">
关于IMUL指令，当乘积截取到64位，无符号乘法和有符号乘法的位级是一样的。而下图的mulq和imulq指令分别实现了$*^u_{64}$和$*^t_{64}$
<img src="/img/books/csapp/chapter3/sp-arithmetic.png" alt="sp-arithmetic"></p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p><img src="/img/books/csapp/chapter3/condition-code.png" alt="condition-code"></p>
<p><img src="/img/books/csapp/chapter3/diff.png" alt="difference"></p>
<h4 id="switch跳转表"><a href="#switch跳转表" class="headerlink" title="switch跳转表"></a>switch跳转表</h4><p>c源码：
<img src="/img/books/csapp/chapter3/csource.png" alt="c-source">
汇编代码：
<img src="/img/books/csapp/chapter3/switch-asm.png" alt="switch-asm">
跳转表(<strong>空间换时间</strong>)：
<img src="/img/books/csapp/chapter3/jump-table.png" alt="jump-table"></p>
<h3 id="浮点的机器层级代码（次要）"><a href="#浮点的机器层级代码（次要）" class="headerlink" title="浮点的机器层级代码（次要）"></a>浮点的机器层级代码（次要）</h3><p><img src="/img/books/csapp/chapter3/float-register.png" alt="f-register"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>assembly code</tag>
      </tags>
  </entry>
  <entry>
    <title>整数和浮点数的表示</title>
    <url>/IT/csapp/integer%20and%20floating-point%20number/</url>
    <content><![CDATA[<h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><h4 id="w-位无符号数和有符号数的逻辑模型"><a href="#w-位无符号数和有符号数的逻辑模型" class="headerlink" title="$w$位无符号数和有符号数的逻辑模型"></a>$w$位无符号数和有符号数的逻辑模型</h4><p><img src="/img/books/csapp/chapter2/unsigned_logicmodel.png" alt="unsigned">
<strong>定义1</strong>：对向量$ \vec x=[x_{w-1},x_{w-2}, … , x_0]$:</p>
<p>$$
B2U_w(\vec x) =\sum_{i=w}^{\infty}0+\sum_{i=0}^{w-1}x_i2^i = \sum_{i=0}^{w-1}x_i2^i
$$
其中，$B2U_w$是二进制转无符号数的函数。</p>
<a id="more"></a>

<p><img src="/img/books/csapp/chapter2/signed_logicmodel.png" alt="signed">
<strong>定义2</strong>：对向量$ \vec x=[x_{w-1},x_{w-2}, … , x_0]$:</p>
<p>\begin{equation}
\begin{aligned}
B2T_w(\vec x) &amp;=\displaystyle{\lim_{k_0 \to \infty}}(-x_{k_0}2^{k_0}+\sum_{j=w-1}^{k_0-1}x_j2^j)+\sum_{i=0}^{w-2}x_i2^i \\
&amp;=\displaystyle{\lim_{k_0 \to \infty}}(-s2^{k_0}+\sum_{j=w-1}^{k_0-1}s2^j)+\sum_{i=0}^{w-2}x_i2^i\\
&amp;=-s2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
\end{aligned}
\end{equation}</p>
<p>其中，$B2T_w$是二进制转补码形式的函数，$s$代表有符号数的符号位的值，<strong>这里将最高有效位解释成负权重</strong>。</p>
<h4 id="补码与无符号数之间的转换"><a href="#补码与无符号数之间的转换" class="headerlink" title="补码与无符号数之间的转换"></a>补码与无符号数之间的转换</h4><p>补码与无符号数之间转换，<strong>数值可能改变，但位模式不变，只是改变解释这些位的方式</strong>。它们数值之间的转换关系如下（<font color="#800">可推导</font>）：
$$
T2U_w(x) = \begin{cases}
x+2^w &amp; x&lt;0 \\
x     &amp; x \geq 0
\end{cases}
$$</p>
<p>$$
U2T_w(u) = \begin{cases}
u-2^w &amp; u&gt;T_{max} \\
u     &amp; u \leq T_{max}
\end{cases}
$$</p>
<p>在c语言中，当执行一个运算，<strong>如果其中一个运算数是有符号数且另外一个是无符号数，c语言会隐式将有符号数转化成无符号数</strong>。</p>
<p><strong>警惕一：</strong> <font color="#800">short转换成unsigned，c语言要求先进行符号扩展，再将无符号数转换成有符号数。</font></p>
<h4 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h4><h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><p><strong>原理1: 补码加法</strong></p>
<blockquote>
<p>对满足$-2^{w-1}\leq x,y \leq 2^{w-1}-1$的整数$x，y$，有：
$$
x+^t_wy = \begin{cases}
x+y-2^w &amp; x+y&gt;2^{w-1}-1 &amp; 正溢出\\
x+y &amp; -2^{w-1}\leq x+y \leq 2^{w-1}-1 &amp; 正常 \\
x+y+2^w &amp; x+y&lt;-2^{w-1} &amp; 负溢出
\end{cases}
$$</p>
</blockquote>
<p><strong>推导1: 补码加法溢出条件</strong></p>
<blockquote>
<p>对满足$-2^{w-1}\leq x,y \leq 2^{w-1}-1$的整数$x，y$，$sum=x+^t_wy$，有：
$$
    sum 溢出 \Leftrightarrow  x和y同号，sum和x异号
$$</p>
</blockquote>
<p><strong>问题1</strong>: 假设$x+y=sum$溢出，$sum-x=?$</p>
<p> 解：根据等价性，假设$x+y=sum$正溢出，<br>
 &ensp; $\because sum=x+^t_wy=x+y-2^w且sum-^t_wx负溢出$<br>
 &ensp; $\therefore sum-^t_wx=x+y-2^w-x+2^w=y$</p>
<blockquote>
<p>画图更直观</p>
</blockquote>
<p>对于无符号数的加法，溢出部分会被自动截断。</p>
<h5 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h5><p><strong>原理2: 补码非</strong></p>
<blockquote>
<p>对满足$TMin_w \leq x \leq TMax_w$的整数$x$，有：
$$
-^t_wx = \begin{cases}
TMin_w &amp; x=TMin_w \\
-x &amp; x\not= TMin_w
\end{cases}
$$</p>
</blockquote>
<p>至于无符号数，它们没有非运算。</p>
<h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p><strong>原理3: 无符号数乘法</strong></p>
<blockquote>
<p>对满足$0 \leq x,y \leq UMax_w$的整数$x，y$，有：
$$
x *^u_w y = (x*y)&ensp;mod&ensp;2^w
$$</p>
</blockquote>
<p><strong>c语言的无符号乘法被定义为产生$w$位的值，就是$2w$位的整数乘积的低$w$位表示的值</strong>。</p>
<p><strong>原理4: 补码乘法</strong></p>
<blockquote>
<p>对满足$TMin_w \leq x,y \leq TMax_w$的整数$x，y$，有：
$$
x *^t_w y = U2^w)
$$</p>
</blockquote>
<p><strong>无符号和补码乘法具有位级等价性</strong>:
$$
T2B_w(x*^t_wy)=U2B_w(x’*^u_wy’)
$$
其原理如下：</p>
<blockquote>
<p>$\because x’*y’=(x+x_{w-1}2^w)*(y+y_{w-1}2^w)
=x*y+(xy_{w-1}+yx_{w-1})2^w+x_{w-1}y_{w-1}2^{2w}$<br>
$\therefore x’*^t_uy’=(x’*y’)\ mod\ 2^w = (x*y)\ mod\ 2^w$<br>
$\because T2U_w(x*^t_wy)=(T2U_w(U2T_w((x*y)\ mod\ 2^w)))=(x*y)\ mod\ 2^w$<br>
$\therefore U2B_w(T2U_w(x*^t_wy))=T2B_w(x*^t_wy)=U2B_w(x’*^t_uy’)$<br></p>
</blockquote>
<h5 id="除以2的幂的补码除法"><a href="#除以2的幂的补码除法" class="headerlink" title="除以2的幂的补码除法"></a>除以2的幂的补码除法</h5><p><strong>警惕二</strong>：<font color="#800">因为需要向零舍入，所以当被除数小于0时，需要加上一个偏置($biasing=2^k-1$)，算术右移才能保证向0舍入.</font></p>
<blockquote>
<p>这是补码格式造成的，而后面的浮点数没有这种正负不同的情况。</p>
</blockquote>
<h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h3><h4 id="IEEE浮点数表示"><a href="#IEEE浮点数表示" class="headerlink" title="IEEE浮点数表示"></a>IEEE浮点数表示</h4><p>小数二进制表示法和IEEE浮点数表示法都<strong>只能精确表示能被写成$x \times 2^y$的数，其他数只能被近似表示</strong>。与前者不同，IEEE浮点表示法可以
表示很大的数。</p>
<blockquote>
<p>IEEE浮点表示：$V=(-1)^s\times M\times 2^E$ <br>
其中，$M$是一个二进制小数，范围是$0\leq M &lt; 1$或者$1\leq M &lt;2$</p>
</blockquote>
<h4 id="单精度和双精度内存格式"><a href="#单精度和双精度内存格式" class="headerlink" title="单精度和双精度内存格式"></a>单精度和双精度内存格式</h4><p><img src="/img/books/csapp/chapter2/floatdouble.png" alt="float-double"></p>
<h4 id="IEEE浮点数重要设计理念"><a href="#IEEE浮点数重要设计理念" class="headerlink" title="IEEE浮点数重要设计理念"></a>IEEE浮点数重要设计理念</h4><blockquote>
<p>理念1：浮点数能够用整数排序函数来排序。当浮点数是正数时，它们按升序排列。</p>
</blockquote>
<blockquote>
<p>理念2：非规化浮点数平滑转换到规格化浮点数</p>
</blockquote>
<h4 id="IEEE浮点数设计"><a href="#IEEE浮点数设计" class="headerlink" title="IEEE浮点数设计"></a>IEEE浮点数设计</h4><h4 id="规格化浮点数"><a href="#规格化浮点数" class="headerlink" title="规格化浮点数"></a>规格化浮点数</h4><p><img src="/img/books/csapp/chapter2/IEEE-normalied.png" alt="normalied"></p>
<blockquote>
<p>阶码E被解释成以偏置格式表示的有符号整数，即$E=e-bias$</p>
</blockquote>
<p>其中，<em>$bias$可以推导出来</em>。</p>
<blockquote>
<p>尾数$M=1+frac$</p>
</blockquote>
<p><strong>这设计是为了2.3的理念2做准备，也可以获得一个额外精度位。</strong></p>
<h4 id="非规格化浮点数"><a href="#非规格化浮点数" class="headerlink" title="非规格化浮点数"></a>非规格化浮点数</h4><p><img src="/img/books/csapp/chapter2/IEEE-unnormalied.png" alt="unnormalied"></p>
<blockquote>
<p>阶码$E=1-bias$，尾数$M=frac$</p>
</blockquote>
<p><strong>这设计是为了遵循2.3的理念2</strong>。</p>
<h4 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h4><p><img src="/img/books/csapp/chapter2/IEEE-infinite.png" alt="infinite"></p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><img src="/img/books/csapp/chapter2/IEEE-NaN.png" alt="NaN">
其中，NaN也用来表示未初始化的数据。</p>
<h4 id="IEEE浮点数的数轴分布情况"><a href="#IEEE浮点数的数轴分布情况" class="headerlink" title="IEEE浮点数的数轴分布情况"></a>IEEE浮点数的数轴分布情况</h4><p><img src="/img/books/csapp/chapter2/IEEE-distribution.png" alt="IEEE-distribution">
可见，数值在-1.0 - 1.0 之间是均匀分布的，而越远离原点数值分布会变得越稀疏，但局部来看仍然是均匀分布。</p>
<h4 id="IEEE浮点数运算"><a href="#IEEE浮点数运算" class="headerlink" title="IEEE浮点数运算"></a>IEEE浮点数运算</h4><h4 id="偶数舍入"><a href="#偶数舍入" class="headerlink" title="偶数舍入"></a>偶数舍入</h4><p>IEEE的浮点数的舍入方式是偶数舍入。它会要求向最接近的值舍入，当它是个中间值时，这种舍入方式倾向使得最低有效数字是偶数，如果是二进制小数，它倾向使得最低有效位是零。</p>
<blockquote>
<p><font color="#800"><strong>警惕三：</strong>当一个数右移时，应该是直接截断（向零舍入）还是需要考虑后面的部分（偶数舍入）。
前者适用于补码，后者适用于浮点数。</font></p>
</blockquote>
<h4 id="IEEE浮点数运算-1"><a href="#IEEE浮点数运算-1" class="headerlink" title="IEEE浮点数运算"></a>IEEE浮点数运算</h4><p><strong>原理5: 浮点数运算</strong></p>
<blockquote>
<p>对实数$x，y$，有：
$$
    x \odot ^f y = Round(x \odot y)
$$
其中，$\odot$是定义在实数上的运算，$Round$是偶数舍入函数。</p>
</blockquote>
<h4 id="IEEE浮点数运算性质"><a href="#IEEE浮点数运算性质" class="headerlink" title="IEEE浮点数运算性质"></a>IEEE浮点数运算性质</h4><p>浮点加法满足可交换性，单调性即$a\geq b \Rightarrow x+a\geq x+b$。另方面因为精度和舍入问题，不满足结合性。</p>
<p>浮点乘法满足可交换性，单调性即
$$
a \geq b 且 c\geq 0 \Rightarrow a*^f c \geq b*^f c \\
a \geq b 且 c\leq 0 \Rightarrow a*^f c \leq b*^f c
$$
但缺乏结合性和分配性。</p>
<h4 id="c语言的浮点数类型转换"><a href="#c语言的浮点数类型转换" class="headerlink" title="c语言的浮点数类型转换"></a>c语言的浮点数类型转换</h4><p><img src="/img/books/csapp/chapter2/cast.png" alt="cast"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>integer</tag>
        <tag>floating-point number</tag>
      </tags>
  </entry>
  <entry>
    <title>myos(三)之断言</title>
    <url>/IT/myos/assert/</url>
    <content><![CDATA[<p>断言是在防御性编程里面占据了非常重要地位的技巧，它们帮助你较早、较轻易地发现错误，使调试过程效率更高。我们用断言来检测程序正常运行时某一个条件是否总为真，它能让错误在运行时刻暴露在程序员面前。</p>
<a id="more"></a>
<h3 id="debug版本和release版本"><a href="#debug版本和release版本" class="headerlink" title="debug版本和release版本"></a>debug版本和release版本</h3><p>一般来说，因为断言多用于程序的debug版本里，所以后面我们要开始区分debug版本和release版本。debug版本使用断言，它的可执行文件中包含了调试信息的.debug节；release版本则没有这些调试信息，还还可以采用优化选项来优化代码。</p>
<p>我们修改Makefile文件，这样就可以根据情况生成debug版本和release版本：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#控制debug的开关，1 表示生成debug版本，0 表示生成release版本</span></span><br><span class="line">debug_switch = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(debug_switch)</span>,1)</span><br><span class="line">	<span class="comment">#debug</span></span><br><span class="line">	C_FLAGS = -c -Wall -m32 -g -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br><span class="line">	ASM_FLAGS = -f elf -g -F stabs</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	<span class="comment">#release</span></span><br><span class="line">	C_FLAGS = -c -Wall -m32  -fno-builtin -fno-stack-protector -I <span class="keyword">include</span> -D NDEBUG</span><br><span class="line">	ASM_FLAGS = -f elf -F stabs</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>上面的代码添加了一个控制是否debug的开关，当需要生成debug版本的时候，C_FLAGS和ASM_FLAGS后面会有-g选项；相反，当需要生成release版本，两者都没有-g选项，而且会要求编译器定义一个NDEBUG的宏。</p>
<h3 id="定义assert的宏"><a href="#定义assert的宏" class="headerlink" title="定义assert的宏"></a>定义assert的宏</h3><p>接下来，我们在头文件定义了assert的宏:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// not debugging, do nothing</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> assert(cond,info)    ( (void)0 )</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//debugging</span></span><br><span class="line">    #define assert(cond,info)         \</span><br><span class="line">        <span class="keyword">if</span>(!(cond))                   \</span><br><span class="line">        &#123;                             \</span><br><span class="line">          panic(info);                \</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//NDEBUG</span></span></span><br></pre></td></tr></table></figure>
<p>如果定义NDEBUG宏的话，程序将什么都不做。否则会判断cond这个条件是否为真，如果是假的话，将使用panic函数来打印出错处的函数调用栈以及其他信息，比如函数所在的文件和行数，并在输出信息最后中断程序。</p>
<h3 id="打印函数调用栈的实现原理"><a href="#打印函数调用栈的实现原理" class="headerlink" title="打印函数调用栈的实现原理"></a>打印函数调用栈的实现原理</h3><p>接下来，我们当然是想实现这个panic函数。但首先我们需要知道它的输出大概是什么样子，才能据此实现它的功能。举个例子，它的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x0010113C</span>] panic (src/kernel/driver/console.c at <span class="built_in">line</span> <span class="number">220</span>)</span><br><span class="line">[<span class="number">0x0010117C</span>] <span class="built_in">vsprintf</span> (src/kernel/driver/console.c at <span class="built_in">line</span> <span class="number">239</span>)</span><br><span class="line">[<span class="number">0x001011E0</span>] <span class="built_in">printf</span> (src/main.c at <span class="built_in">line</span> <span class="number">13</span>)</span><br><span class="line">Entry function : main</span><br></pre></td></tr></table></figure>
<p>输出部分包括了函数调用栈里每一个函数被调用时的内存地址（<strong>后面统一称为calling address</strong>），函数名，被调用时所在的文件名以及行数。下面将这四项拆开仔细讲解。</p>
<h4 id="函数被调用时的内存地址"><a href="#函数被调用时的内存地址" class="headerlink" title="函数被调用时的内存地址"></a>函数被调用时的内存地址</h4><p>此项是上面4项中最重要的，需要知道这个calling address才查得到其他3项。如果我们想拿到它，我们首先应该理解函数调用时的重要机制：<strong>调用者先将参数压栈，再将返回的地址压栈，接着执行call 0xaddr 这条调用指令</strong>。被调用者一开始会先执行以下两行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov  esp,ebp</span><br></pre></td></tr></table></figure>
<p>此时，局部的栈空间如下所示：</p>
<p><img src="/img/myos/chapter-3_stack.png" alt="stack"></p>
<p>从上图可以看出，在栈空间里，紧接着返回地址的下面是旧ebp的值，在mov esp,ebp 这语句之后，ebp就会指向栈里如图所示的位置。所以，我们可以通过读取ebp的值，再将ebp的值加上4 (<em>旧ebp的值占用了4字节</em>) ,便可得到指向返回地址的指针。</p>
<p>再者，call 0xaddr这条指令占了5个字节，因为call指令本身占了一字节，函数地址0xaddr占了4字节。所以，我们将返回地址减去5便得到calling address。</p>
<p>目前我们只拿到一个calling address，既然我们需要打印函数调用栈，所以还需要调用栈里面其它所有calling address。解决问题关键之处在于上图的旧ebp之上。下面的图能够帮助读者更直观地了解：</p>
<p><img src="/img/myos/chapter-3_ebp.png" alt="ebp"></p>
<p>假设我们现在拿到的是 $ebp_n$ ，那我们可以利用这个指针取出$ebp_{n-1}$的值，以此类推，我们可以往上取出调用栈所有的calling address。在这个循环里，我们取到内核入口函数Entry function即main函数这层便结束。</p>
<h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>接着，我们要根据calling address得到所对应的函数名。</p>
<p>在elf文件里有一个称作.symtab的节段，这个section实质是一个表，包含众多的表项，每个表项代表一个符号，它的数据结构可以表达成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> st_name;</span><br><span class="line">    <span class="keyword">uint16_t</span> st_value;</span><br><span class="line">    <span class="keyword">unti16_t</span> st_size;</span><br><span class="line">    <span class="keyword">uint8_t</span>  st_info;</span><br><span class="line">    <span class="keyword">uint8_t</span>  st_other;</span><br><span class="line">    <span class="keyword">uint16_t</span> st_shndx;</span><br><span class="line">&#125; <span class="keyword">elf32_symbol_t</span>;</span><br></pre></td></tr></table></figure>
<p>之所以特别表明elf32，是因为elf64下对应的数据结构会不一样。我们看下里面重要的变量。</p>
<p>st_name是这个符号在.strtab节的偏移量，就是说，我们需要.strtab的首地址和st_name这个偏移才能得到符号名。st_value在elf可执行文件里面是一个虚拟内存地址，如果这符号是函数的话，这个值在这里代表这个函数的内存起始地址，st_size也就代表了函数占用的字节大小。st_info用于判断这个符号的类型，比如函数或变量。</p>
<p>根据上面的数据结构，首先，我们筛选出函数类型的符号，再看上一节得到的calling address是不是在符号的地址区间$[st\_value,st\_value+st\_size)$之中。如果在这个区间里面，那么calling address就是属于这个函数的。</p>
<p>这样，我们便在查找函数名的过程里前进了一大步。现在的问题变成，我们要怎么得到.strtab和.symtab的首地址呢?</p>
<p>幸运的是，在GRUB引导我们的内核时，它会将一些重要的section信息加载进一个类型为multiboot_t的数据结构里，它里面有4个变量跟section信息相关：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> num;</span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> addr;</span><br><span class="line"><span class="keyword">uint32_t</span> shstrndx;</span><br></pre></td></tr></table></figure>
<p>其中，addr是节头部表（section header table）的地址，mun和size是section header table表项的数量和大小，shstrndx是段表字符串节(.shstrtab节)在section header table的索引，用于寻找.shstrtab节的首地址，而.shstrtab节用于存放各section的名字字符串。</p>
<p>每个section header都有一个变量sh_name，与上面的st_name类似，它仅是一个偏移量，结合它和.shstrtab的首地址才能找到该section 的节名称。因此，我们可以通过找section的名字，一对比便可以找到.strtab和.symtab的section header。在section header里的变量sh_addr便是它们的首地址。</p>
<h4 id="函数被调用时所在的文件名"><a href="#函数被调用时所在的文件名" class="headerlink" title="函数被调用时所在的文件名"></a>函数被调用时所在的文件名</h4><p>这部分需要借助.debug_info节段，.debug_info节需要编译器开启-g选项才能生成。linux下包括调试信息的节，包括.debug_info和后面的.debug_line，都遵循DWARF（<strong>Debugging With Attributed Record Formats</strong>）格式的设计。.debug_info节里面包含了核心DWARF数据，基本包含了如函数、参数、变量、类型等等大部分信息。</p>
<p>如果我们只想单纯地找到函数被调用时的文件名，其实并不一定需要.debug_info信息，我们仅仅凭借3.3.4小节的.debug_line节便可以完成。但我们借助.debug_info加载的信息可以较快速，优雅地完成3.3.4任务(可以从代码看出)。</p>
<p>.debug_info节包含了较详细的调试信息，但仅仅为了完成panic的功能，我们仅仅需要其中小部分的信息，debug_info节包含了很多Compilation Units（CU），每个CU对应一个源码文件，基本包括了一个源文件内部的如函数、参数、变量、类型等信息。这些函数，变量等都可以用debugging information entrie（DIE）来描述，每个DIE都包含了相关的标签和属性。</p>
<p>我们仅需要关注.debug_info的每一个CU头，以及CU的第一个DIE。因为第一个DIE描述了这个源文件的包括文件路径名和文件的内存范围的信息。</p>
<p>.debug_info的CU头的数据结构是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elf32_debug_info_CU_header_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> length;  <span class="comment">//CU_size + CU_header_size - sizeof(length)</span></span><br><span class="line">	<span class="keyword">uint16_t</span> version;</span><br><span class="line">	<span class="keyword">uint32_t</span> abbrev_offset;</span><br><span class="line">	<span class="keyword">uint8_t</span> pointer_size;</span><br><span class="line">&#125; __attribute__((packed)) elf32_debug_info_CU_header_t;</span><br></pre></td></tr></table></figure>
<p>这里面对我们最重要的就是与CU大小有联系的length变量，它帮助我们遍历每一个CU。还有就是，因为系统是32位系统，所以pointer_size是4，表示占用了4个字节。</p>
<p>第一个DIE的数据结构是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elf32_debug_info_file_DIE_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> abbrev_num;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_producer;</span><br><span class="line">	<span class="keyword">uint8_t</span> DW_AT_language;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_name; 		<span class="comment">//filename 偏移量</span></span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_comp_dir;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_low_pc; 		<span class="comment">//起始内存地址</span></span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_high_pc;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_stmt_list;</span><br><span class="line">&#125;__attribute__((packed))  elf32_debug_info_file_DIE_t;</span><br></pre></td></tr></table></figure>
<p>这部分对我们重要的是DW_AT_name，DW_AT_low_pc和DW_AT_high_pc。其中DW_AT_name表示源文件的文件名在.debug_str节的偏移（所以还需要.debug_str节才能找到名字）。DW_AT_low_pc表示源文件的起始内存地址。</p>
<p>当call adress在$[DW\_AT\_low\_pc,DW\_AT\_low\_pc+DW\_AT\_high\_pc)$区间里，就表示这个地址在这源文件的内存范围里。于是，我们就取出该文件的文件名。</p>
<h4 id="函数被调用时的行数"><a href="#函数被调用时的行数" class="headerlink" title="函数被调用时的行数"></a>函数被调用时的行数</h4><p>接下来，我们就开始寻找函数被调用时所在的行数，这得借助elf文件的.debug_line节。它里面包含的信息可以确定源码的内存地址所对应的行数。想弄懂下面的内容的读者最好粗略看看<a href="http://dwarfstd.org/doc/DWARF4.pdf" target="_blank" rel="noopener">DWARF4的官方文档</a>的6.2小节。</p>
<p>类似地，.debug_line节也由很多CU组成。每个CU有一个CU头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elf32_debug_line_CU_heaher_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;  <span class="comment">//CU_size + CU_header_size - sizeof(length)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> header_length;</span><br><span class="line">    <span class="keyword">uint8_t</span>  min_instruction_length;</span><br><span class="line">    <span class="keyword">uint8_t</span>  default_is_stmt;</span><br><span class="line">    <span class="keyword">int8_t</span>   line_base;</span><br><span class="line">    <span class="keyword">uint8_t</span>  line_range;</span><br><span class="line">    <span class="keyword">uint8_t</span>  opcode_base;</span><br><span class="line">    <span class="keyword">uint8_t</span>  std_opcode_lengths[<span class="number">12</span>];</span><br><span class="line">&#125; __attribute__((packed)) elf32_debug_line_CU_header_t;</span><br></pre></td></tr></table></figure>
<p>这数据结构对我们比较有用的变量是min_instruction_length、line_base、line_range和opcode_base，这几个变量对文章后面的一种重要操作有决定性的作用，但它们的含义并不重要。</p>
<p>紧紧挨着CU头的便是记录了该源文件相关的目录及其文件名的信息。首先是目录信息，一开始是第一个目录，名字字符串在内存中以ascii码十六进制的形式存储。每一目录的字符串都以0x00字节结束。当整个目录信息结束时，它会以另一个0x00结尾。文件名的信息与目录信息的情况类似，除了还提供这文件在哪个目录下等额外信息。下面看个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">The Directory <span class="title">Table</span> <span class="params">(offset <span class="number">0x13a</span>)</span>:</span></span><br><span class="line"><span class="function"> 1	kernel</span></span><br><span class="line"> 2	./lib</span><br><span class="line"></span><br><span class="line"><span class="function">The <span class="built_in">File</span> Name <span class="title">Table</span> <span class="params">(offset <span class="number">0x148</span>)</span>:</span></span><br><span class="line"><span class="function"> Entry	Dir	Time	Size	Name</span></span><br><span class="line"> 1	1	0	0	heap.c</span><br><span class="line"> <span class="number">2</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">0</span>	libc.h</span><br></pre></td></tr></table></figure>
<p>上面的信息说明heap.c在kernel目录下，libc.h在./lib目录下，而heap.c源文件include了libc.h头文件。我们看看它对应的.debug_line信息内存数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x6B65726E</span> <span class="number">656</span>C00: <span class="string">"kernel"</span> (first directory)</span><br><span class="line"><span class="number">0x2E2F6C69</span> <span class="number">6200</span>: <span class="string">"./lib"</span> (second directory)</span><br><span class="line"><span class="number">0x00</span>: <span class="built_in">end</span> of the directories</span><br><span class="line"><span class="number">0x68656170</span> <span class="number">2E6300</span>: <span class="string">"heap.c"</span> (first file)</span><br><span class="line"><span class="number">0x010000</span>: Dir=<span class="number">1</span> (<span class="string">"kernel"</span>), Time=<span class="number">0</span>, Size=<span class="number">0</span></span><br><span class="line"><span class="number">0x6C696263</span> <span class="number">2E6800</span>: <span class="string">"libc.h"</span> (second file)</span><br><span class="line"><span class="number">0x020000</span>: Dir=<span class="number">2</span> (<span class="string">"./lib"</span>), Time=<span class="number">0</span>, Size=<span class="number">0</span></span><br><span class="line"><span class="number">0x00</span>: <span class="built_in">end</span> of the files</span><br></pre></td></tr></table></figure>
<p>CU剩余部分都是三个操作的内容：Standard opcodes，Extended opcodes 和 Special opcodes。当开头的第一个字节大小在1-12之间，表示是Standard opcodes；如果是0，则是Extended opcodes；最后如果是大于等于13，则是special opcodes。</p>
<p>在三者之中，special opcodes会直接改变地址寄存器和行寄存器的值。它改变地址和行数寄存器的方式是：</p>
<p>$$ \begin{equation} \begin{split} 
&amp;pc+=\frac{Opcode-Opcode\_base}{Line\_base}  * Min\_instruction\_length \\
&amp;line += Line\_base + (Opcode - Opcode\_base)\% Line\_range 
\end{split} \end{equation} $$
上面的Opcode便是我们的special opcodes码，公式右边的其他变量全是CU头里面定义的变量。</p>
<p>除了special opcodes，我们还需要关注Standard opcodes的DW_LNS_advance_pc、DW_LNS_advance_line、DW_LNS_const_add_pc这些操作，以及Extended opcodes的DW_LNE_set_address操作。这些操作都改变内存寄存器或行数寄存器。当然，为了完成整个解析过程，我们还需要看看其他操作。除了前面提到的，我们的代码暂时还考虑了Standard op的DW_LNS_copy、DW_LNS_negate_stmt以及Extended op的DW_LNE_SET_DISCRIMINATOR、DW_LNE_END_SEQUENCE.</p>
<p>现在假设解析完了第i条opcode，当前内存和行数寄存器的值分别是$pc_i$和$line_i$。那么当解析完第i+1条opcode后，它们将是$pc_{i+1}$ 和 $line_{i+1}$。它们之间的关系是：</p>
<p>$$
pc_{i+1}=pc_i+\Delta pc
$$</p>
<p>$$
line_{i+1}=line_i+\Delta line
$$</p>
<p>在这里，$\Delta pc$和$\Delta line$都可以是0。当我们发现$pc_{i+1}$第一次大于我们之前取得的calling address，那么$line_i$就是我们要找的行数（<strong>当然，前提是我们已经确定该调用地址就在这个CU代表的源文件里</strong>）。</p>
<h3 id="打印函数调用栈的实现"><a href="#打印函数调用栈的实现" class="headerlink" title="打印函数调用栈的实现"></a>打印函数调用栈的实现</h3><p>由于篇幅有限，这里将比较少涉及到实现细节。</p>
<h4 id="panic函数的骨架"><a href="#panic函数的骨架" class="headerlink" title="panic函数的骨架"></a>panic函数的骨架</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">panic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ebp, *return_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有初始化debug信息的话</span></span><br><span class="line">    <span class="keyword">if</span>(!is_debug_initialized)</span><br><span class="line">    &#123;</span><br><span class="line">        init_debug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------- System panic:%s ------\n"</span>,msg);</span><br><span class="line">    <span class="comment">//得到当前ebp寄存器的值</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"mov %%ebp, %0"</span> : <span class="string">"=r"</span> (ebp))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回地址=ebp指向的内存地址+4字节</span></span><br><span class="line">        return_addr = ebp + <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call 0xaddr 占了五字节</span></span><br><span class="line">        call_addr = *return_addr - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找函数名</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.debug_info</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.debug_line</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上一层函数栈的ebp</span></span><br><span class="line">        ebp=(<span class="keyword">uint8_t</span>*)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//halt</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>panic首先看系统之前有没有初始化过调试信息、得到过elf节段关键信息，接着内嵌汇编语句得到ebp的值，这样便可以顺藤摸瓜找到函数栈里上一层函数的returning address和calling address，利用这个地址查找函数名，所在文件名和行数，再依次找到再上一层的被调用地址，并重复以上的操作。</p>
<p>init_debug函数会调用load_elf()函数加载elf节段的信息。</p>
<h4 id="load-elf函数"><a href="#load-elf函数" class="headerlink" title="load_elf函数"></a>load_elf函数</h4><p>这阶段的load_elf暂时只为了实现assert功能，也就是只加载.strtab、.symtab、.debug_info、.debug_str和.debug_line节段。后面如果有其它需要才继续细化load_elf函数。</p>
<p>拿到elf各个节段的内存地址，我们必须借助前面提到的multiboot_t数据类型。grub模块会将相关信息存放在这个数据结构里，并将指向这结构的指针存放在ebx寄存器里。因为在boot.s里，我们在调用main函数里将ebx压入栈内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">  push    ebx                   ; ebx存放了multiboot头的内存地址</span><br><span class="line">  ; Execute the kernel:</span><br><span class="line">  cli                         ; 禁止中断</span><br><span class="line">  call main                   ; 调用c源码的main函数</span><br><span class="line">  jmp $                       ; 进入无限循环</span><br></pre></td></tr></table></figure>
<p>根据参数入栈的原理，我们需要在main函数里增加multiboot_t*类型的参数，并且在main函数内赋值给全局的g_multiboot_p指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">multiboot_t</span> * _multiboot_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    g_multiboot_p=_multiboot_p;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是load_elf()函数的骨架：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 multiboot_t 结构获取ELF信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_elf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// section headers</span></span><br><span class="line">    <span class="keyword">elf32_section_header_t</span> *sh = (<span class="keyword">elf32_section_header_t</span> *)g_multiboot_p-&gt;addr;</span><br><span class="line">    <span class="comment">//.shstrab节存储了sections的名称字符串</span></span><br><span class="line">    <span class="keyword">uint32_t</span> shstrtab = sh[g_multiboot_p-&gt;shstrndx].sh_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历每一个section header</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_multiboot_p-&gt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *section_name = (<span class="keyword">const</span> <span class="keyword">char</span> *)(shstrtab + sh[i].sh_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".strtab"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".symtab"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".debug_info"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".debug_str"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".debug_line"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载后，panic函数便可以进去while循环开始解析各个section，这过程的原理上面已经大体讲完，由于有不少的细节，这里就不再一一讲述。</p>
<p>当我们在panic的骨架上添加完细节，整个断言部分便已经完成了。</p>
<h3 id="文件目录结构以及变更"><a href="#文件目录结构以及变更" class="headerlink" title="文件目录结构以及变更"></a>文件目录结构以及变更</h3><p><img src="/img/myos/chapter-3_dir.png" alt="dir"></p>
]]></content>
      <categories>
        <category>operating system</category>
      </categories>
      <tags>
        <tag>myos</tag>
      </tags>
  </entry>
  <entry>
    <title>myos(二)之屏幕输出函数</title>
    <url>/IT/myos/printing-to-screen/</url>
    <content><![CDATA[<p>上章成功搭建了编写内核的工作环境，为了能跟内核进行初步的交互，紧接着要实现的便是内核的屏幕输出功能。</p>
<a id="more"></a>
<h3 id="屏幕输出的原理"><a href="#屏幕输出的原理" class="headerlink" title="屏幕输出的原理"></a>屏幕输出的原理</h3><p>为了在显示器显示文字，我们需要显卡的帮忙。显卡的作模式包括文本模式和图片模式，我们这里只讲简单的文本模式。既然显卡需要显示数据，这些数据肯定需要内存空间来存储。内存中存储显卡的数据的区域被称为显存，而物理内存的0xB8000-0xBFFFF这段内存区域映射了文本模式的显存。</p>
<p>计算机在加电自检后会自动将文本模式初始化为80*25的模式，在这种分辨率下，一个屏幕可以显示25行，一行显示80个字符。其中，每个字符占用了内存16 bits的空间，高8位定义了字符的backcolor和forecolor，后面8位存储这个字符的ascii码。它的结构如下：</p>
<p><img src="/img/myos/chapter-2_rbg.png" alt="rbg"></p>
<p>至于backcolor和forecolor字段什么值对应什么颜色，读者可以自己查阅资料。</p>
<p>除了这些显示的存储内容之外，我们还需要去使用显示的控制单元来完成一些特定的功能，比如设置光标的位置。为了读写这些控制单元，我们需要用到特殊的in/out指令来完成，这里将使用端口来作为内部寄存器的索引。</p>
<p><strong>在pc机上，0x3d4和0x3d5两个端口用来读写显卡的内部寄存器。</strong>其中，我们要往0x3d4端口写入要访问的寄存器编号，再通过0x3d5端口读写寄存器数据。</p>
<h3 id="屏幕输出的代码实现"><a href="#屏幕输出的代码实现" class="headerlink" title="屏幕输出的代码实现"></a>屏幕输出的代码实现</h3><h4 id="端口读写函数"><a href="#端口读写函数" class="headerlink" title="端口读写函数"></a>端口读写函数</h4><p>首先我们需要实现端口读写函数的实现，而c语言里面没有直接操作端口的方法，我们将借助c语言的内联汇编。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////端口读///////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span> <span class="title">inportb</span> <span class="params">(<span class="keyword">uint16_t</span> _port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> rv;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"inb %1, %0"</span> : <span class="string">"=a"</span> (rv) : <span class="string">"dN"</span> (_port));</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint16_t</span> <span class="title">inportw</span> <span class="params">(<span class="keyword">uint16_t</span> _port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> rv;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"inw %1, %0"</span> : <span class="string">"=a"</span> (rv) : <span class="string">"Nd"</span> (_port));</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////端口写///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">outportb</span> <span class="params">(<span class="keyword">uint16_t</span> _port, <span class="keyword">uint8_t</span> _data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"outb %1, %0"</span> : : <span class="string">"dN"</span> (_port), <span class="string">"a"</span> (_data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">outportw</span> <span class="params">(<span class="keyword">uint16_t</span> _port, <span class="keyword">uint16_t</span> _data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"outw %1, %0"</span> : : <span class="string">"dN"</span> (_port), <span class="string">"a"</span> (_data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="宏定义、变量定义和函数原型"><a href="#宏定义、变量定义和函数原型" class="headerlink" title="宏定义、变量定义和函数原型"></a>宏定义、变量定义和函数原型</h4><p>接着，为了代码可读性，我们定义相关的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显卡文本模式的屏幕分辨率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SCREEN_ROW 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SCREEN_COL 80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文本模式显存的物理内存起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_START  0xb8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过0x3d4端口告知需要访问哪个显卡的寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_REGISTER_PORT 0x3d4</span></span><br><span class="line"><span class="comment">//通过0x3d5端口读写显卡的寄存器数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_DATA_PORT 0x3d5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存放光标的高8位的显卡寄存器编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUR_REG_HIGH   14</span></span><br><span class="line"><span class="comment">//存放光标的低8位的显卡寄存器编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUR_REG_LOW    15</span></span><br></pre></td></tr></table></figure>
<p>以及定义重要的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显卡文本模式显存的指针</span></span><br><span class="line"><span class="keyword">uint16_t</span>* video_pointer;</span><br><span class="line"><span class="comment">//光标的x,y坐标</span></span><br><span class="line"><span class="keyword">uint8_t</span>  x_cur=<span class="number">0</span>,y_cur=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//前景，背景的颜色，默认黑底白字</span></span><br><span class="line"><span class="keyword">uint16_t</span> text_color;</span><br></pre></td></tr></table></figure>

<p>屏幕输出操作的函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置指向文本模式显存的指针,以及清屏</span></span><br><span class="line"><span class="comment">//必须在使用console模块其他函数之前调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_video</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_screen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_text_color</span><span class="params">( <span class="keyword">text_color_t</span> backcolor,<span class="keyword">text_color_t</span> forecolor)</span></span>;</span><br><span class="line"><span class="comment">//重置输出文本的颜色，默认黑底白字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_test_color</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putch</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span>  <span class="keyword">char</span> * str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里为了直观，给出三个静态函数的原型，实际上在该文件并不用声明静态函数。</p>
<h4 id="光标位置更新"><a href="#光标位置更新" class="headerlink" title="光标位置更新"></a>光标位置更新</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//光标移动</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_cursor</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了一步步实现以上函数，我们需要实现作为基础的更新光标位置函数，它是一个静态函数，只在console模块里被使用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">udpate_cursor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//光标的一维线性位置</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cursor_location= y_cur * MAX_SCREEN_COL + x_cur; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//光标位置的线性数据存放在两个显卡寄存器里，分别是它的高8位和低8位数据</span></span><br><span class="line"></span><br><span class="line">    outportb(CUR_REGISTER_PORT,CUR_REG_HIGH);   <span class="comment">//告知要操作光标的高8位寄存器</span></span><br><span class="line">    outportb(CUR_DATA_PORT,cursor_location&gt;&gt;<span class="number">8</span>); <span class="comment">//往高8位寄存器里写数据</span></span><br><span class="line"></span><br><span class="line">    outportb(CUR_REGISTER_PORT,CUR_REG_LOW);   <span class="comment">//告知要操作光标的低8位寄存器</span></span><br><span class="line">    outportb(CUR_DATA_PORT,cursor_location);   <span class="comment">//往低8位寄存器里写数据</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h4><p>说白了，清屏就是将文本模式的显存全部设置成空格符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_screen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>  t_color = colorcat(t_white, t_black);</span><br><span class="line">    <span class="comment">//空格符</span></span><br><span class="line">    <span class="keyword">uint16_t</span> blank = (t_color&lt;&lt;<span class="number">8</span>) | BLANK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将文本模式的显存全部设置成空格符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX_SCREEN_ROW * MAX_SCREEN_COL; i++)</span><br><span class="line">        video_pointer[i]=blank;</span><br><span class="line"></span><br><span class="line">    x_cur=y_cur=<span class="number">0</span>;</span><br><span class="line">    update_cursor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="屏幕滚动显示"><a href="#屏幕滚动显示" class="headerlink" title="屏幕滚动显示"></a>屏幕滚动显示</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//屏幕滚动显示</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scroll_screen</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>当字符占满屏幕时，屏幕就要向上滚动，以显示接下来的字符。简单地说，它的逻辑实际就是将后24行的数据全部向上挪动一行，最后一行清空：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scroll_screen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>  t_color = colorcat(t_white, t_black);</span><br><span class="line">    <span class="comment">//空格符</span></span><br><span class="line">    <span class="keyword">uint16_t</span> blank = (t_color&lt;&lt;<span class="number">8</span>) | BLANK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//光标到达最下方，该滚动屏幕</span></span><br><span class="line">    <span class="keyword">if</span> ( y_cur &gt;= MAX_SCREEN_ROW )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//将前面除了第一行外的所有行数据复制到上一行</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MAX_SCREEN_ROW * MAX_SCREEN_COL - MAX_SCREEN_COL; i++)</span><br><span class="line">            video_pointer[i]=video_pointer[i+MAX_SCREEN_COL];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一行设置成空格符</span></span><br><span class="line">        <span class="keyword">for</span> (; i&lt; MAX_SCREEN_ROW * MAX_SCREEN_COL ;i++)</span><br><span class="line">            video_pointer[i]=blank;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//屏幕滚动一行，所以光标要向上移动一行</span></span><br><span class="line">        y_cur--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h4><p>这部分重点在于实现putch函数，puts只是在其基础上重复输出。而putch函数一开始还是要识别出输出字符是可打印字符还是一些有特殊含义的字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putch</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> * char_location;</span><br><span class="line">    <span class="comment">/*Carriage Return*/</span></span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'\r'</span>)</span><br><span class="line">        x_cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x_cur=<span class="number">0</span>;</span><br><span class="line">        y_cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退格</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==BACKSPACE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x_cur&gt;<span class="number">0</span>)</span><br><span class="line">            x_cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Handles a tab by incrementing the cursor's x*/</span></span><br><span class="line">    <span class="comment">/*but only to a point that will make it divisible by 8*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==TAB)</span><br><span class="line">        x_cur=(x_cur+<span class="number">8</span>)&amp;~(<span class="number">8</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//any charactor greater than and inclu-</span></span><br><span class="line">    <span class="comment">//ding a space  is a printfable charactor</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">' '</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        char_location= video_pointer + y_cur * MAX_SCREEN_COL + x_cur;</span><br><span class="line"></span><br><span class="line">        *char_location = c | (text_color&lt;&lt;<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        x_cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x_cur&gt;=MAX_SCREEN_COL)</span><br><span class="line">    &#123;</span><br><span class="line">        x_cur=<span class="number">0</span>;</span><br><span class="line">        y_cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有必要的话滚动屏幕</span></span><br><span class="line">    scroll_srceen();</span><br><span class="line">    <span class="comment">//更新光标位置</span></span><br><span class="line">    update_cursor();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span>  <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        putch(str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h4><p>前面已经实现了输出字符串的功能，但我们还缺少一个基本的格式化屏幕输出函数，下面一步步实现printf函数。首先我们看看调用printf函数时候堆栈会发生什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"these numbers are : %d,%d,%d,%d"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>这句话的汇编代码大概是这样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 4</span><br><span class="line">push 3</span><br><span class="line">push 2</span><br><span class="line">push 1</span><br><span class="line">push $0xaddr</span><br><span class="line">call printf</span><br><span class="line">sub esp,20</span><br></pre></td></tr></table></figure>
<p>根据cdecl约定，函数参数会依照从右到左的顺序入栈。上面$0xaddr代表字符串“these numbers are : %d,%d,%d,%d”的地址。在这之后它的栈内容是：</p>
<p><img src="/img/myos/chapter-2_stack.png" alt="stack"></p>
<p>上图的内存地址只是相对地址，指向格式化字符串的指针format string addr占用了4字节的空间。如果我们想将格式化字符串正确打印出来，换句话就是找到每个%d对应的值，必须根据内存栈正确处理printf的变长参数。我们这里用宏定义辅助：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* va_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让args_pointer指向变长参数的起始地址，format代表格式化字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(args_pointer,format) \</span></span><br><span class="line">    (args_pointer = (va_list)&amp;format + <span class="keyword">sizeof</span>(format) )</span><br><span class="line"><span class="comment">//返回当前参数的值，并让args_pointer指向下一个参数的地址,type表示当前参数的数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_args(args_pointer,type) \</span></span><br><span class="line">    (*(type*) ( (args_pointer + =<span class="keyword">sizeof</span>(type)) - <span class="keyword">sizeof</span>(type) ) )</span><br><span class="line"><span class="comment">//置为空指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(args_pointer) \</span></span><br><span class="line">    (args_pointer=(va_list)<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>上面的是va_start，va_args，va_end的简单版本实现。我们将它用在printf函数的代码里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];  <span class="comment">//将格式化字符串的%-形式的字符串替换成对应的值，处理后的字符串将存储在buff中</span></span><br><span class="line">    <span class="keyword">int</span> buff_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list将指向可变参数列表的第一个参数</span></span><br><span class="line">    va_list <span class="built_in">list</span>;</span><br><span class="line">    va_start(<span class="built_in">list</span>,format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vsprintf将格式化字符串的%-形式的字符串替换成对应的值，将处理后的字符串存储在buff中</span></span><br><span class="line">    buff_index=<span class="built_in">vsprintf</span>(buff,format,<span class="built_in">list</span>); <span class="comment">//buf_index将表示存储在buff的字符串后面一位的下标。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//置为空指针</span></span><br><span class="line">    va_end(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出处理过的字符串</span></span><br><span class="line">    buff[buff_index]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">puts</span>(buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面很容易看出，vsprintf将是完成printf函数的关键。vsprintf的功能主要是将格式化字符串的%-形式的字符串替换成对应的值，将处理后的字符串存储在buff中。这里的vsprintf很简单，也仅仅实现了处理%d、%x、%c、%s的情况，以后有需要会增加其他情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将格式化字符串的%-形式的字符串替换成对应的值，将处理后的字符串存储在buff中</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param buff : 存储处理后的字符串</span></span><br><span class="line"><span class="comment"> * @param format : 格式化字符串，即待处理字符串</span></span><br><span class="line"><span class="comment"> * @param list :   指向可变参数列表里的参数的指针</span></span><br><span class="line"><span class="comment"> * @return int :   buff字符串末尾下一位的下标</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *buff,<span class="keyword">const</span> <span class="keyword">char</span>*format,va_list <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buff_index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> itoa_str[<span class="number">32</span>];          <span class="comment">//存放整型转换后的字符串</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>  int_value;             <span class="comment">//用于%d</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uint_value;    <span class="comment">//用于%x</span></span><br><span class="line">    <span class="keyword">char</span> char_value;            <span class="comment">//用于%c</span></span><br><span class="line">    <span class="keyword">char</span> * string_addr;         <span class="comment">//用于%s</span></span><br><span class="line">    <span class="comment">//顺序处理format字符串每一个字符</span></span><br><span class="line">    <span class="keyword">for</span>(; *format; format++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前字符是普通字符,直接复制</span></span><br><span class="line">        <span class="keyword">if</span>(*format!=<span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buff[buff_index++]=*format;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//当前字符是‘%’</span></span><br><span class="line">    format++;</span><br><span class="line">    <span class="keyword">switch</span>(*format)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//整型</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                <span class="comment">//取出这个整型</span></span><br><span class="line">                int_value=va_args(<span class="built_in">list</span>,<span class="keyword">int</span>);</span><br><span class="line">                <span class="comment">//10进制转换</span></span><br><span class="line">                itoa(int_value,itoa_str,<span class="number">10</span>);</span><br><span class="line">                len=<span class="built_in">strlen</span>(itoa_str);</span><br><span class="line">                <span class="comment">//将转换后的字符串复制到buff上</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;buff[buff_index], itoa_str, len);</span><br><span class="line">                buff_index+=len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//字符</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">                <span class="comment">//注意，因为入栈用的push，即使是char变量，esp也要加4，所以不能用va_args(list,char)</span></span><br><span class="line">                char_value=va_args(<span class="built_in">list</span>,<span class="keyword">int32_t</span>);</span><br><span class="line">                buff[buff_index]=char_value;</span><br><span class="line">                buff_index++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//字符串</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                string_addr=va_args(<span class="built_in">list</span>,<span class="keyword">char</span>*);</span><br><span class="line">                len=<span class="built_in">strlen</span>(string_addr);</span><br><span class="line">                <span class="comment">//将字符串复制到buff上</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;buff[buff_index],string_addr,len);</span><br><span class="line">                buff_index+=len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//16进制</span></span><br><span class="line">            <span class="keyword">case</span><span class="number">'</span>x<span class="number">'</span>:</span><br><span class="line">                uint_value=va_args(<span class="built_in">list</span>,<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">                <span class="comment">//16进制转换</span></span><br><span class="line">                itoa(uint_value,itoa_str,<span class="number">16</span>);</span><br><span class="line">                len=<span class="built_in">strlen</span>(itoa_str);</span><br><span class="line">                <span class="comment">//将转换后的字符串复制到buff上</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;buff[buff_index], itoa_str, len);</span><br><span class="line">                buff_index+=len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不符合以上情况</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">//TODO panic</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//end of switch</span></span><br><span class="line">    &#125;<span class="comment">//end of for</span></span><br><span class="line">    <span class="keyword">return</span> buff_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试屏幕输出函数"><a href="#测试屏幕输出函数" class="headerlink" title="测试屏幕输出函数"></a>测试屏幕输出函数</h4><p>最后，我们在main函数测试下我们的console模块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_video();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* name=<span class="string">"binson"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello myos!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置成黑底红字</span></span><br><span class="line">    set_text_color( t_black, t_red  );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello myos!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The string \"%s\" has %d characters beginning with \'%c\',and its address is 0x%x\n"</span>, \</span><br><span class="line">            name,<span class="built_in">strlen</span>(name),name[<span class="number">0</span>],name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置颜色</span></span><br><span class="line">    reset_test_color();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello myos!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的效果如下：</p>
<p><img src="/img/myos/chapter-2_hello-myos.png" alt="hello-myos"></p>
<h3 id="文件目录结构以及变更"><a href="#文件目录结构以及变更" class="headerlink" title="文件目录结构以及变更"></a>文件目录结构以及变更</h3><p><img src="/img/myos/chapter-2_dir.png" alt="dir"></p>
<p>这里新增了一种文件状态描述符 r，代表rename操作。它的语法是 r&emsp;filename&emsp;:旧路径+旧文件名&emsp; -&gt; ./ ，其中filename是现在的文件名，旧路径会以/开头，表示此os项目的根目录，后面的-&gt; ./ 表示移动到当前目录。上面的 r&emsp;boot.s&emsp;/boot.s&emsp;-&gt; ./ 的意思就是从原来在项目根目录下的boot.s移动到当前目录下，而名字并没有改变。</p>
<p>还有就是dir和floppy.img这些文件起始也有变化，但我们这里只关注源码文件。</p>
]]></content>
      <categories>
        <category>operating system</category>
      </categories>
      <tags>
        <tag>myos</tag>
      </tags>
  </entry>
  <entry>
    <title>myos(一)之搭建环境</title>
    <url>/IT/myos/environment-setup/</url>
    <content><![CDATA[<p><strong>本文假设你使用的是linux操作系统</strong>，使用windows的朋友可以建个虚拟机。如果读者觉得本系列课程有些关键的术语和知识点弄不懂，建议使用搜索引擎弄明白，或者看下《深入理解计算机系统》这本书打下坚实的基础。</p>
<a id="more"></a>
<h3 id="先写一个简单的内核"><a href="#先写一个简单的内核" class="headerlink" title="先写一个简单的内核"></a>先写一个简单的内核</h3><p>首先，我们需要先写个引导代码，这部分代码用的是intel风格汇编语言。这个boot.s的内容如下:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   boot.s -- 内核从这里开始</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; ----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Multiboot 魔数，由规范决定的</span></span><br><span class="line">MBOOT_HEADER_MAGIC  <span class="built_in">equ</span>     <span class="number">0x1BADB002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 0 号位表示所有的引导模块将按页(4KB)边界对齐</span></span><br><span class="line">MBOOT_PAGE_ALIGN    <span class="built_in">equ</span>     <span class="number">1</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息</span></span><br><span class="line"><span class="comment">; (告诉GRUB把内存空间的信息包含在Multiboot信息结构中)</span></span><br><span class="line">MBOOT_MEM_INFO      <span class="built_in">equ</span>     <span class="number">1</span> &lt;&lt; <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">; 定义我们使用的 Multiboot 的标记</span></span><br><span class="line">MBOOT_HEADER_FLAGS  <span class="built_in">equ</span>     MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO</span><br><span class="line"></span><br><span class="line"><span class="comment">; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)</span></span><br><span class="line"><span class="comment">; 相加时，要求其结果必须是32位的无符号值 0 (即magic+flags+checksum = 0)</span></span><br><span class="line">MBOOT_CHECKSUM      <span class="built_in">equ</span>     -(MBOOT_HEADER_MAGIC+MBOOT_HEADER_FLAGS)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头</span></span><br><span class="line"><span class="comment">; Multiboot 头的分布必须如下表所示：</span></span><br><span class="line"><span class="comment">; ----------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 偏移量  类型  域名        备注</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   0     u32   magic       必需</span></span><br><span class="line"><span class="comment">;   4     u32   flags       必需 </span></span><br><span class="line"><span class="comment">;   8     u32   checksum    必需 </span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 我们只使用到这些就够了，更多的详细说明请参阅 GNU 相关文档</span></span><br><span class="line"><span class="comment">;-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------------------------------------------------------------------</span></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="comment">; 在代码段的起始位置设置符合 Multiboot 规范的标记</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dd</span> MBOOT_HEADER_MAGIC   <span class="comment">; GRUB 会通过这个魔数判断该映像是否支持</span></span><br><span class="line"><span class="built_in">dd</span> MBOOT_HEADER_FLAGS   <span class="comment">; GRUB 的一些加载时选项，其详细注释在定义处</span></span><br><span class="line"><span class="built_in">dd</span> MBOOT_CHECKSUM       <span class="comment">; 检测数值，其含义在定义处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;; GLOBAL extern;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line">[<span class="meta">GLOBAL</span> start]                  <span class="comment">; 内核入口</span></span><br><span class="line">[<span class="meta">EXTERN</span> main]                   <span class="comment">; c代码的入口</span></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;; start ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">  <span class="keyword">push</span>    <span class="built_in">ebx</span>                   <span class="comment">; ebx存放了multiboot头的内存地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; Execute the kernel:</span></span><br><span class="line">  <span class="keyword">cli</span>                         <span class="comment">; 禁止中断</span></span><br><span class="line">  <span class="keyword">call</span> main                   <span class="comment">; 调用c源码的main函数</span></span><br><span class="line">  <span class="keyword">jmp</span> $                       <span class="comment">; 进入无限循环</span></span><br></pre></td></tr></table></figure>
<p>因为我们暂时不准备写引导程序，而是使用现成的GRUB来引导。这个boot.s的1-34行就是跟GRUB的multiboot标准相关的代码，这部分不懂也不影响后面的内容，有兴趣的朋友可以自己查阅GRUB的multiboot标准的资料。</p>
<p>第49行便是内核的入口，当GRUB成功引导内核后，ebx寄存器存放的便是multiboot头的内存地址。在第52行里，这个文件便会调用外部的c文件的main函数，如果c函数返回的话，下一句的jmp $ 便会让内核进入无限循环。下面我们开始写c源码的文件main.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个c文件很简单，它的main函数一开始便返回。</p>
<p>在完成简单内核的编写后，接着我们新建一个Makefile文件，下面我们逐步会完善这个文件。到本章结束，我们只需要输入简单的语句，它就可以帮助我们完成编译、链接、运行、调试的过程。</p>
<h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>本操作系统大部分源码都是用c语言完成，我们将使用gcc来编译源代码。项目将使用汇编语言作为辅助，我们将使用nasm编译器来编译汇编(如果你机器下没有nasm，就先下载个)。下面我们在Makefile文件里添加相关编译语句:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC  = gcc</span><br><span class="line">ASM = nasm</span><br><span class="line"></span><br><span class="line">C_FLAGS   = -c -Wall -m32 -g -nostdinc -fno-builtin -fno-stack-protector</span><br><span class="line">ASM_FLAGS = -f elf -g -F stabs</span><br><span class="line"></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	@echo 编译代码文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(C_FLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="section">.s.o:</span></span><br><span class="line">	@echo 编译汇编文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(ASM)</span> <span class="variable">$(ASM_FLAGS)</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>上面的语句帮助我们生成相关源文件的elf可重定位目标文件。</p>
<p>下面说说C_FLAGS和ASM_FlAGS两个变量中与本项目比较相关的选项。其中，-m32是告诉编译器帮助我们生成32位的可重定位目标文件，-nostdlibnc告诉编译器不使用系统的头文件，-fno-builtin则让编译器不使用C语言的内建函数。nasm 的 -f elf 是要输出elf可重定位目标文件，如果不指定输出文件格式，默认输出格式将是bin。</p>
<p>其他选项如果不懂的话可以通过“gcc –help”和”nasm –help”查询。</p>
<h3 id="链接环境"><a href="#链接环境" class="headerlink" title="链接环境"></a>链接环境</h3><p>我们将使用ld来链接上面步骤的可重定位目标文件，类似的，我们往Makefile文件添加以下语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LD &#x3D; ld</span><br><span class="line"></span><br><span class="line">LD_FLAGS &#x3D; -T scripts&#x2F;link.ld -m elf_i386 -nostdlib</span><br><span class="line"></span><br><span class="line">link:</span><br><span class="line">	@echo 链接内核文件...</span><br><span class="line">	$(LD) $(LD_FLAGS) $(S_OBJECTS) $(C_OBJECTS) -o Fredix</span><br></pre></td></tr></table></figure>
<p>“-nostdlib”告诉链接器仅搜索那些在命令行上显式指定的库路径。”-m elf_i386”要求生成i386的elf可执行文件。”-T”选项用于指定自定义的脚本文件，而链接器将会使用这个脚本定义的规则来精确控制目标文件的格式。这里，链接器则使用位于子目录scripts的link.ld文件。它的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRY(start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*段起始位置*&#x2F;</span><br><span class="line">	. &#x3D; 0x100000;</span><br><span class="line"></span><br><span class="line">	.text :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.data :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.data)</span><br><span class="line">		*(.rodata)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.bss :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stab :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stab)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stabstr :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stabstr)</span><br><span class="line">	 	. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;DISCARD&#x2F; : &#123; *(.comment) *(.eh_frame) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这脚本首先告诉链接器程序的入口在‘start’符号处,接着第一个段是.text段，它的起始位置是0x100000(即内存1MB处)，接着便是存放初始化数据的.data段和未初始化数据段的.bss段。linux gcc会增加一个额外的只读初始化数据段的.rodata段，为了方便，我们将它放在.data段里面。后面的.stab和.stabstr段存放的是调试相关的信息。</p>
<h3 id="内核映像"><a href="#内核映像" class="headerlink" title="内核映像"></a>内核映像</h3><p>上面步骤的链接器会生成一个名称为Fredix的可执行文件。我们会将这个可执行文件放进一个内核映像中，这样我们就可以使用虚拟机来运行我们的内核了。</p>
<p>前面说过，我们将直接使用GRUB来引导我们的内核。本项目提供了一个有着GRUB模块的floppy.img的映像文件，大家可以在我的<a href="https://github.com/wu-binson/binux" target="_blank" rel="noopener">github</a>里下载。一开始这个映像文件并没有内核的可执行文件，所以我们需要在Makefile文件里添加以下语句，来往img文件放置内核文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:update_image</span><br><span class="line">update_image:</span><br><span class="line">	sudo mount floppy.img &#x2F;mnt&#x2F;</span><br><span class="line">	sudo cp Fredix &#x2F;mnt&#x2F;Fredix</span><br><span class="line">	sleep 1</span><br><span class="line">	sudo umount &#x2F;mnt</span><br></pre></td></tr></table></figure>
<p>上面的语句只是将几条步骤捆绑起来，我们完全可以手动一条条地完成。</p>
<p>需要注意的是，如果读者想给自己的内核取个不一样的名字，除了需要改掉链接步骤和update_image步骤的Fredix，还需要修改img文件里的boot/grub/grub.conf文件和/boot/grub/menu.lst文件(步骤类似上面，先挂载，再修改)。它们的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title&#x3D;Fredix</span><br><span class="line">root (fd0)</span><br><span class="line">kernel &#x2F;Fredix</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 1</span><br><span class="line"></span><br><span class="line">title    Fredix	</span><br><span class="line">	root (fd0)</span><br><span class="line">	kernel &#x2F;Fredix</span><br><span class="line"></span><br><span class="line">module &#x2F;modules&#x2F;hello</span><br></pre></td></tr></table></figure>
<p>由于篇幅有限，这里并没有写出Makefile的全部内容，具体情况请看github的文件。这时，我们在终端输入”make”之后，便会自动完成编译，链接和制造内核映像的过程。</p>
<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>有了内核映像之后，我们需要一个虚拟机来运行我们的内核，可以选择bochs或qemu，这里选择qemu来运行。于是我们往Makefile添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:qemu</span><br><span class="line">qemu:</span><br><span class="line">	qemu-system-i386 -fda floppy.img -boot a</span><br></pre></td></tr></table></figure>
<p>接着输入“make qemu”,如果没有什么错误的话，将会出现下图：</p>
<p><img src="/img/myos/chapter-1_runtime.png" alt="runtime"></p>
<h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p>我们将用gdb调试内核，第一步骤往Makefile添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:debug</span><br><span class="line">debug:</span><br><span class="line">	qemu-system-i386 -S -s -fda floppy.img -boot a &amp;</span><br><span class="line">	sleep 1</span><br><span class="line">	gdb -tui -x scripts&#x2F;gdbinit</span><br></pre></td></tr></table></figure>
<p>上面多出来的-s跟-gdb tcp::1234的意义一样,也就是监听1234端口，等待gdb的连接，-S表示CPU将在开始时暂停，用c命令才能继续运行。第三句的gdb启动时将运行gdbinit脚本，以下是他的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file Fredix</span><br><span class="line">target remote :1234</span><br><span class="line">break main</span><br><span class="line">set disassembly-flavor intel</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>第一句加载我们的内核文件并获取符号表，接着连接1234端口，在main函数设置断点，用汇编语言风格设置为intel，最后的c是continue的意思。</p>
<p>接着我们仅需要输入“make debug”就可以进入gdb界面调试我们的程序。</p>
<p><img src="/img/myos/chapter-1_gdb.png" alt="gdb"></p>
<h3 id="文件目录结构以及变更"><a href="#文件目录结构以及变更" class="headerlink" title="文件目录结构以及变更"></a>文件目录结构以及变更</h3><p>至此，我们的基本环境就已经搭建好了，下面给出当前的目录结构：</p>
<p><img src="/img/myos/chapter-1_dir.png" alt="dir"></p>
<p>上图的+表示刚刚创建，后面还有！表示修改过，如果读者想对比两个文件有何不同，推荐使用meld。</p>
]]></content>
      <categories>
        <category>operating system</category>
      </categories>
      <tags>
        <tag>myos</tag>
      </tags>
  </entry>
</search>
