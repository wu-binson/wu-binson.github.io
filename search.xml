<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学会提问(三)之理由是什么</title>
    <url>/note/critical_thinking/reason/</url>
    <content><![CDATA[<p>理由是用来支撑结论的重要基石。想客观评价一个结论的价值，分析支撑它的理由是必不可少的步骤。当支撑这个结论的理由非常脆弱或不堪一击，那么表面看似多么有道理的结论都理应受到质疑。反之，即使我们暂时不认同某个结论，我们也要仔细琢磨它的理由。</p>
<h3 id="理由-结论-论证"><a href="#理由-结论-论证" class="headerlink" title="理由+结论=论证"></a>理由+结论=论证</h3><p>简单来讲，论证的过程就是用一个或多个想法来支撑另外一个想法的过程。它具备几个特性：</p>
<ul>
<li><strong>论证必有其目的</strong>。一般论证的目的是让我们相信它的结论或者按照它的建议去完成某一件事情。</li>
<li><strong>论证质量有高低之分</strong>。</li>
<li><strong>论证有两个明显的必要构成成分：结论和理由</strong>。如果我们找不到一篇文章里的这两个部分，就失去客观评价这论证的机会。</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>①中学阶段的男篮和男足常常一统周五晚上的节目单，应不应该是这个样子？②这些比赛对中学经历的人而言意义非凡，但也不至于为此牺牲掉其他所有运动项目。③仅仅因为他们有悠久传统并不意味着这种模式就一定要世代因循。
④周五晚上腾出时间观看比赛对大多数父母和球迷而言自然要容易得多。⑤因此，周五晚上他们亲自来看男篮和男足比赛自然也很容易。
⑥那么女子篮球队或游泳队又怎么办呢？⑦她们的比赛不应该总是被安排在周一到周五下午和晚上举行。⑧她们的家人经常不能腾出时间来观看她们的比赛，因为大多数父母下午都要上班。⑨那些参加这些“二流”体育运动的学生根本没有得到聚光灯的平等关注。⑩男篮和男足的日程表应该做出相应改变，为其他体育活动腾出一点空间。</p>
<p><strong>论题</strong>：中学阶段的周五晚上节目单应不应该清一色是男篮或男足？</p>
<p><strong>结论</strong>：男篮和男足的日程表应该做出相应改变，为其他体育活动腾出一点空间。</p>
<p><strong>理由</strong>：</p>
<ol>
<li>虽然男篮和男足有悠久的传统，但不至于牺牲掉其他所有项目。
②③句</li>
<li>其他项目被迫安排到其他不利于观看的时间段，受到了不平等的对待 
⑦⑧⑨句</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>critical thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>学会提问(一)之批判性提问技能</title>
    <url>/note/critical_thinking/summary/</url>
    <content><![CDATA[<h3 id="批判性提问技能的适用场景和重要性"><a href="#批判性提问技能的适用场景和重要性" class="headerlink" title="批判性提问技能的适用场景和重要性"></a>批判性提问技能的适用场景和重要性</h3><p>批判性提问技能是一项非常重要的技能，它的适用范围非常广，几乎可以运用到生活的各个角落。</p>
<p>随着互联网和物联网对现代文明的进一步渗透，以及近年来自媒体的兴起，每个上网的人都可以发出自己的声音。这些信息的质量有高有低，这个时候理性地分辨出哪些是虚假信息，哪些言论存在漏洞，哪些是经得起推敲的观点，是非常重要的。而批判性提问技能可以帮助我们在信息洪流里站稳脚跟。</p>
<p>在与互联网不相关的地方，比如学习和阅读，批判性提问也能够让我们比较充分地参与到这个过程中，能够帮助我们集中精神。当我们针对书籍材料的观点提出一些问题并尝试着去思考时，我们将可以对这些材料有着更深入的理解，这过程还会附带成就感。</p>
<p>这种技能还适用另外一个重要的场景，就是科学研究的过程。科学研究的本质就是站在前人的理论上提出自己的理论（<em>理论是特殊的观点</em>）。科学理论几乎都有着自身时代的局限性，比如牛顿力学只能解释宏观层面的现象。用批判性思维看待科学理论有助于我们提出新的，更先进的理论。</p>
<p>除了上面提到的，还有很多其它的场景，所以这种技能的重要性便不言而喻了。结合上面的场景，个人认为，它的重要性主要体现在以下三大方面：</p>
<ol>
<li><strong>帮助你选择性过滤掉来自外界的观点。</strong>在充分思考后，你可以自主选择地支持一些观点，这时的你应该可以说出自己支持这些观点的理由，甚至还可以找到瑕疵之处。同时，你可能会不赞成一些观点，在这过程中顺便能找到反驳的理由。</li>
<li><strong>除了过滤外界的观点，批判性提问法能让我们审视自己的观点。</strong>在批判性看待自己的观点后，我们可以更加肯定或者修正甚至否定之前的观点。提出一个由许多小观点组成的大观点，或者写文章等类似活动类似于程序员写各种软件系统，程序员都知道，几乎很少有不存在漏洞的完美系统，而且系统越大出漏洞的概率就越大，所以我们能做的只是尽可能地填上漏洞。而批判提问法帮助我们发现自己的文章或者观点里面的漏洞所在，及时修补上。</li>
<li>如上面所说，<strong>批判性提问技能帮助我们充分参与到学习，阅读，各种会议等活动中</strong>。另外，我们可以凭借提出的关键问题顺藤摸瓜，搜寻到某类问题的答案。</li>
</ol>
<h3 id="何为批判性提问和批判性思维"><a href="#何为批判性提问和批判性思维" class="headerlink" title="何为批判性提问和批判性思维"></a>何为批判性提问和批判性思维</h3><p>这里先解释下批判性提问(critical-questioning)，批判性提问这个术语由两个部分组成，分别是批判性思维和提问。提问的目的自然是提出关键问题，而批判性思维就是为了这个目标所服务。至于批判性思维，书中给出了这样的解释，它主要涵盖了以下几个方面：</p>
<ul>
<li>有一套相互关联、环环相扣的关键问题的意识。</li>
<li>恰如其分地提出和回答关键问题的能力。</li>
<li>积极主动地利用关键问题的强烈愿望。</li>
</ul>
<p>书的目的便是激发读者朝这三个方面全面发展。
从批判性思维用途的角度出发，可以将批判性思维分成<strong>弱势批判性思维</strong>和<strong>强势批判性思维</strong>。其中弱势批判性思维的目的是抵制和驳倒与你观点不同的论述，并不关心自己的观点能否更接近真理。弱势批判性思维最大的问题在于尽力维护的观点可能一开始就是错的。强势批判性思维的目的恰恰相反，它要求我们一视同仁地对待别人和自己的观点。</p>
<h3 id="批判性提问的可操作步骤"><a href="#批判性提问的可操作步骤" class="headerlink" title="批判性提问的可操作步骤"></a>批判性提问的可操作步骤</h3><h4 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h4><ol>
<li><a href="https://wubinson.github.io/note/critical_thinking/thesis/" target="_blank" rel="noopener">论题和结论是什么</a></li>
<li><a href="https://wubinson.github.io/note/critical_thinking/reason/" target="_blank" rel="noopener">理由是什么</a></li>
<li>哪些词语不明确</li>
<li>什么是价值观假设和描述性假设</li>
<li>推理过程有没有谬误</li>
<li>证据的效力如何</li>
<li>有没有替代原因</li>
<li>数据有没有欺骗性</li>
<li>有什么重要信息被省略了</li>
<li>能得出哪些合理的结论</li>
</ol>
<p>上面的步骤暂时仅需要初步了解下，<strong>每一个步骤都是后面的章节</strong>，后面会详细讲解。</p>
<h4 id="勤加练习"><a href="#勤加练习" class="headerlink" title="勤加练习"></a>勤加练习</h4><p>只知道这种技能的存在却不会使用之仅仅比不知道概念强一点，想掌握技能需要大量的练习。除了书中每章节后面的练习题，生活中的各种观点都应该被视为我们潜在的练习题。</p>
<h3 id="两个重要的意识"><a href="#两个重要的意识" class="headerlink" title="两个重要的意识"></a>两个重要的意识</h3><h4 id="对话交流可以促进进步"><a href="#对话交流可以促进进步" class="headerlink" title="对话交流可以促进进步"></a>对话交流可以促进进步</h4><p>不要封堵住与别人交流对话的渠道，甚至需要我们主动去创造交流的机会。与别人的交流可以修正你的观点，即使你对自己的观点很有信心，即使对方看似各方面都不如你（<em>很多时候是错觉</em>）。</p>
<h4 id="你有没有可能是错的"><a href="#你有没有可能是错的" class="headerlink" title="你有没有可能是错的"></a>你有没有可能是错的</h4><p>在你对自己的观点很有自信，快要到”蔑视”其它观点的时候，都应该问问自己，你有没有可能是错的。很多程序员都有这样的经历：在开发复杂的软件系统的过程，许多躲藏在思维盲区的bug会不停地冲击他们的自以为是。而实现世界又是一个极其复杂的系统。</p>
<h3 id="批判性思维的弊端"><a href="#批判性思维的弊端" class="headerlink" title="批判性思维的弊端"></a>批判性思维的弊端</h3><p>批判性思维的好处很多，当然它也会有弊端。它比海绵思维需要更多的注意力，在使用批判性思维这个工具的时候，它会消耗掉使用者一定的精力。人的精力是有限的，所以<strong>我们应该将这个强大的工具使用在重要的场景</strong>。掌握起来不容易也算是这个工具的弊端之一。</p>
<p>还有就是，生活上很多观点有很多细节是不能证实或者不能证伪的，有部分是因为人类使用的语言系统的原因，比如“很多程序员喜欢写c”这句话，里面的“很多”是很模糊的，“很多”到底是多少，占了多大的比例，这些都是不得而知的。碰到这种情况，批判性思维会建议我们保持怀疑的态度，这也是一个追求真理的学者必须具备的素质。但生活里有些情况是需要快速决断的，比如一个领导者在重大决断前面对下属的犹豫时间越长，有时候给团队带来的危害会越严重（开始是精神层面的，后面可能导致团队瓦解），甚至会比做出错误决断还要严重。</p>
<h3 id="一个小问题——关于批判思维的思考对象"><a href="#一个小问题——关于批判思维的思考对象" class="headerlink" title="一个小问题——关于批判思维的思考对象"></a>一个小问题——关于批判思维的思考对象</h3><p>查阅了一些关于批判性思维的材料和定义，似乎没有个统一或者明确点的说法。<strong>个人更倾向认为，批判性思维这个工具剖析的对象是各种被假设或者逻辑支撑起来的观点（<em>因为观点都是人提出来的，所以都与人相关</em>），而不是自然界客观存在的事物。至少书中教导我们的批判性提问技能就是这种</strong>。这种技能是“提出关键问题”技能的子集，前者没有后者的范围广。比如，在科研面对一些自然现象，科学家会提出一些关于客观存在的事物的关键问题，来驱动自己的研究。批判性提问技能在这里是不适用的（看看本文3.1的步骤）,它适用的场景是当你面对别人的论文和理论的时候。虽然如此，它仍然是非常重要的工具，知道它的局限性可以让我们使用起来更加游刃有余。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>critical thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>学会提问(二)之论题和结论</title>
    <url>/note/critical_thinking/thesis/</url>
    <content><![CDATA[<h3 id="论题的分类"><a href="#论题的分类" class="headerlink" title="论题的分类"></a>论题的分类</h3><p>论题是引起对话或者讨论的问题，是后续讨论的驱动力。它主要分成两大类：
1.<strong>描述性论题</strong>。这类论题讨论的是世界过去、现在、未来是什么样。它的例子如下：</p>
<ul>
<li>PHP是不是世界上最好的语言？</li>
<li>中国能不能取代美国成为世界第一？</li>
<li>上个好大学重要吗？</li>
<li>一般来讲，女生学习语言的能力是不是比男生强？</li>
</ul>
<p>2.<strong>规定性论题</strong>。这类论题讨论的是世界应该是什么样子的，什么是对的是什么错的，什么该有什么不该有。它的例子如下：</p>
<ul>
<li>应不应该鼓励大学生创业？</li>
<li>要不要和异地的网友谈恋爱？</li>
<li>选择高校应不应该将城市作为重要因素来考虑？</li>
<li>学校应不应该规范学生的穿着？</li>
</ul>
<p>有些文章的论题很容易看出，有些却非常隐晦，这时可以先找结论，再反推论题。很多时候，这两种论题总是成对紧密地出现。比如，一篇文章的标题是“晨练好还是晚练好”，最后的结论是晚练更有益，我们应该晚练（这不是我的结论）。只看标题我们知道题目是一个描述性命题，但看到结论我们可以知道文章暗含着规定性命题，也就是“我们应该晨练还是晚练”。这里的规定性论题的结论由描述性命题的结论很自然地推出。</p>
<h3 id="结论与纯观点"><a href="#结论与纯观点" class="headerlink" title="结论与纯观点"></a>结论与纯观点</h3><p>结论是逐步推断出来的，来源于推理。一个结论由其他证据或者观点支撑起来。没有证据支撑的断言不能算结论，只能称为纯观点。还有，例句、数据、定义、背景资料和证据这些东西不可能是结论。</p>
<h3 id="当我们自己写作的时候"><a href="#当我们自己写作的时候" class="headerlink" title="当我们自己写作的时候"></a>当我们自己写作的时候</h3><p>1 将论题的范围尽量缩小
2 引导读者得出你的结论</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>critical thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的机器级表示</title>
    <url>/note/csapp/asm/</url>
    <content><![CDATA[<h3 id="1-ensp-数据格式"><a href="#1-ensp-数据格式" class="headerlink" title="1.&ensp;数据格式"></a>1.&ensp;数据格式</h3><p><font color="#ff0000"><strong>Intel</strong>使用术语表示16位数据类型。所以32位数被称为double word，同理，64位被称为quad word。</font></p>
<h3 id="2-ensp-整数寄存器和数据传送指令"><a href="#2-ensp-整数寄存器和数据传送指令" class="headerlink" title="2.&ensp;整数寄存器和数据传送指令"></a>2.&ensp;整数寄存器和数据传送指令</h3><p>·<img src="/img/books/csapp/chapter3/i-register.png" alt="整数寄存器">
·<img src="/img/books/csapp/chapter3/mov.png" alt="mov">
<font color="#ff0000">比较特别的是，当movl指令以寄存器作为目的，它会把寄存器的高4位字节设置为0.</font></p>
<p>以下两类数据移动指令，<strong>用于较小的源值复制到较大的目的寄存器的时候</strong>。
·<img src="/img/books/csapp/chapter3/movz.png" alt="movz">
·<img src="/img/books/csapp/chapter3/movs.png" alt="movs"></p>
<p>考虑到以下的指令:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">src_t</span> *sp;</span><br><span class="line"><span class="keyword">dest_t</span> *dp;</span><br><span class="line"></span><br><span class="line">*dp=(<span class="keyword">dest_t</span>)*sp;</span><br></pre></td></tr></table></figure>
<p>假设sp和dp的值分别存储在%rdi和%rsi的寄存器里，src_t是char，dest_t是unsigned。那么*dp=(dest_t)*sp;对应的汇编代码
是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movsbl (%rdi),%eax;</span><br><span class="line">movl %eax,(%rsi);</span><br></pre></td></tr></table></figure>
<h3 id="3-ensp-算术和逻辑操作"><a href="#3-ensp-算术和逻辑操作" class="headerlink" title="3.&ensp;算术和逻辑操作"></a>3.&ensp;算术和逻辑操作</h3><p><img src="/img/books/csapp/chapter3/arithmetic.png" alt="arithmetic">
关于IMUL指令，当乘积截取到64位，无符号乘法和有符号乘法的位级是一样的。而下图的mulq和imulq指令分别实现了$*^u_{64}$和$*^t_{64}$
<img src="/img/books/csapp/chapter3/sp-arithmetic.png" alt="sp-arithmetic"></p>
<h3 id="4-ensp-控制"><a href="#4-ensp-控制" class="headerlink" title="4.&ensp;控制"></a>4.&ensp;控制</h3><h4 id="4-1-ensp-条件码"><a href="#4-1-ensp-条件码" class="headerlink" title="4.1&ensp;条件码"></a>4.1&ensp;条件码</h4><p><img src="/img/books/csapp/chapter3/condition-code.png" alt="condition-code"></p>
<p><img src="/img/books/csapp/chapter3/diff.png" alt="difference"></p>
<h4 id="4-2-ensp-switch跳转表"><a href="#4-2-ensp-switch跳转表" class="headerlink" title="4.2&ensp;switch跳转表"></a>4.2&ensp;switch跳转表</h4><p>c源码：
<img src="/img/books/csapp/chapter3/csource.png" alt="c-source">
汇编代码：
<img src="/img/books/csapp/chapter3/switch-asm.png" alt="switch-asm">
跳转表(<strong>空间换时间</strong>)：
<img src="/img/books/csapp/chapter3/jump-table.png" alt="jump-table"></p>
<h3 id="5-ensp-浮点的机器层级代码（次要）"><a href="#5-ensp-浮点的机器层级代码（次要）" class="headerlink" title="5.&ensp;浮点的机器层级代码（次要）"></a>5.&ensp;浮点的机器层级代码（次要）</h3><p><img src="/img/books/csapp/chapter3/float-register.png" alt="f-register"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>assembly code</tag>
      </tags>
  </entry>
  <entry>
    <title>整数和浮点数的表示</title>
    <url>/note/csapp/integer%20and%20floating-point%20number/</url>
    <content><![CDATA[<h3 id="1-ensp-整数表示"><a href="#1-ensp-整数表示" class="headerlink" title="1.&ensp;整数表示"></a>1.&ensp;整数表示</h3><h4 id="1-1-ensp-w-位无符号数和有符号数的逻辑模型"><a href="#1-1-ensp-w-位无符号数和有符号数的逻辑模型" class="headerlink" title="1.1&ensp;$w$位无符号数和有符号数的逻辑模型"></a>1.1&ensp;$w$位无符号数和有符号数的逻辑模型</h4><p><img src="/img/books/csapp/chapter2/unsigned_logicmodel.png" alt="unsigned">
<strong>定义1</strong>：对向量$ \vec x=[x_{w-1},x_{w-2}, … , x_0]$:</p>
<p>$$
B2U_w(\vec x) =\sum_{i=w}^{\infty}0+\sum_{i=0}^{w-1}x_i2^i = \sum_{i=0}^{w-1}x_i2^i
$$
其中，$B2U_w$是二进制转无符号数的函数。</p>
<p><img src="/img/books/csapp/chapter2/signed_logicmodel.png" alt="signed">
<strong>定义2</strong>：对向量$ \vec x=[x_{w-1},x_{w-2}, … , x_0]$:</p>
<p>\begin{equation}
\begin{aligned}
B2T_w(\vec x) &amp;=\displaystyle{\lim_{k_0 \to \infty}}(-x_{k_0}2^{k_0}+\sum_{j=w-1}^{k_0-1}x_j2^j)+\sum_{i=0}^{w-2}x_i2^i \\
&amp;=\displaystyle{\lim_{k_0 \to \infty}}(-s2^{k_0}+\sum_{j=w-1}^{k_0-1}s2^j)+\sum_{i=0}^{w-2}x_i2^i\\
&amp;=-s2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
\end{aligned}
\end{equation}</p>
<p>其中，$B2T_w$是二进制转补码形式的函数，$s$代表有符号数的符号位的值，<strong>这里将最高有效位解释成负权重</strong>。</p>
<h4 id="1-2-ensp-补码与无符号数之间的转换"><a href="#1-2-ensp-补码与无符号数之间的转换" class="headerlink" title="1.2&ensp;补码与无符号数之间的转换"></a>1.2&ensp;补码与无符号数之间的转换</h4><p>补码与无符号数之间转换，<strong>数值可能改变，但位模式不变，只是改变解释这些位的方式</strong>。它们数值之间的转换关系如下（<font color="#800">可推导</font>）：
$$
T2U_w(x) = \begin{cases}
x+2^w &amp; x&lt;0 \\
x     &amp; x \geq 0
\end{cases}
$$</p>
<p>$$
U2T_w(u) = \begin{cases}
u-2^w &amp; u&gt;T_{max} \\
u     &amp; u \leq T_{max}
\end{cases}
$$</p>
<p>在c语言中，当执行一个运算，<strong>如果其中一个运算数是有符号数且另外一个是无符号数，c语言会隐式将有符号数转化成无符号数</strong>。</p>
<p><strong>警惕一：</strong> <font color="#800">short转换成unsigned，c语言要求先进行符号扩展，再将无符号数转换成有符号数。</font></p>
<h4 id="1-3-ensp-整数运算"><a href="#1-3-ensp-整数运算" class="headerlink" title="1.3&ensp;整数运算"></a>1.3&ensp;整数运算</h4><h5 id="1-3-1-ensp-加法"><a href="#1-3-1-ensp-加法" class="headerlink" title="1.3.1&ensp;加法"></a>1.3.1&ensp;加法</h5><p><strong>原理1: 补码加法</strong></p>
<blockquote>
<p>对满足$-2^{w-1}\leq x,y \leq 2^{w-1}-1$的整数$x，y$，有：
$$
x+^t_wy = \begin{cases}
x+y-2^w &amp; x+y&gt;2^{w-1}-1 &amp; 正溢出\\
x+y &amp; -2^{w-1}\leq x+y \leq 2^{w-1}-1 &amp; 正常 \\
x+y+2^w &amp; x+y&lt;-2^{w-1} &amp; 负溢出
\end{cases}
$$</p>
</blockquote>
<p><strong>推导1: 补码加法溢出条件</strong></p>
<blockquote>
<p>对满足$-2^{w-1}\leq x,y \leq 2^{w-1}-1$的整数$x，y$，$sum=x+^t_wy$，有：
$$
    sum 溢出 \Leftrightarrow  x和y同号，sum和x异号
$$</p>
</blockquote>
<p><strong>问题1</strong>: 假设$x+y=sum$溢出，$sum-x=?$</p>
<p> 解：根据等价性，假设$x+y=sum$正溢出，<br>
 &ensp; $\because sum=x+^t_wy=x+y-2^w且sum-^t_wx负溢出$<br>
 &ensp; $\therefore sum-^t_wx=x+y-2^w-x+2^w=y$</p>
<blockquote>
<p>画图更直观</p>
</blockquote>
<p>对于无符号数的加法，溢出部分会被自动截断。</p>
<h5 id="1-3-2-ensp-非运算"><a href="#1-3-2-ensp-非运算" class="headerlink" title="1.3.2&ensp;非运算"></a>1.3.2&ensp;非运算</h5><p><strong>原理2: 补码非</strong></p>
<blockquote>
<p>对满足$TMin_w \leq x \leq TMax_w$的整数$x$，有：
$$
-^t_wx = \begin{cases}
TMin_w &amp; x=TMin_w \\
-x &amp; x\not= TMin_w
\end{cases}
$$</p>
</blockquote>
<p>至于无符号数，它们没有非运算。</p>
<h5 id="1-3-3-ensp-乘法"><a href="#1-3-3-ensp-乘法" class="headerlink" title="1.3.3&ensp;乘法"></a>1.3.3&ensp;乘法</h5><p><strong>原理3: 无符号数乘法</strong></p>
<blockquote>
<p>对满足$0 \leq x,y \leq UMax_w$的整数$x，y$，有：
$$
x *^u_w y = (x*y)&ensp;mod&ensp;2^w
$$</p>
</blockquote>
<p><strong>c语言的无符号乘法被定义为产生$w$位的值，就是$2w$位的整数乘积的低$w$位表示的值</strong>。</p>
<p><strong>原理4: 补码乘法</strong></p>
<blockquote>
<p>对满足$TMin_w \leq x,y \leq TMax_w$的整数$x，y$，有：
$$
x *^t_w y = U2T_w((x*y)&ensp;mod&ensp;2^w)
$$</p>
</blockquote>
<p><strong>无符号和补码乘法具有位级等价性</strong>:
$$
T2B_w(x*^t_wy)=U2B_w(x’*^u_wy’)
$$
其原理如下：</p>
<blockquote>
<p>$\because x’*y’=(x+x_{w-1}2^w)*(y+y_{w-1}2^w)
=x*y+(xy_{w-1}+yx_{w-1})2^w+x_{w-1}y_{w-1}2^{2w}$<br>
$\therefore x’*^t_uy’=(x’*y’)\ mod\ 2^w = (x*y)\ mod\ 2^w$<br>
$\because T2U_w(x*^t_wy)=(T2U_w(U2T_w((x*y)\ mod\ 2^w)))=(x*y)\ mod\ 2^w$<br>
$\therefore U2B_w(T2U_w(x*^t_wy))=T2B_w(x*^t_wy)=U2B_w(x’*^t_uy’)$<br></p>
</blockquote>
<h5 id="1-3-4-ensp-除以2的幂的补码除法"><a href="#1-3-4-ensp-除以2的幂的补码除法" class="headerlink" title="1.3.4&ensp;除以2的幂的补码除法"></a>1.3.4&ensp;除以2的幂的补码除法</h5><p><strong>警惕二</strong>：<font color="#800">因为需要向零舍入，所以当被除数小于0时，需要加上一个偏置($biasing=2^k-1$)，算术右移才能保证向0舍入.</font></p>
<blockquote>
<p>这是补码格式造成的，而后面的浮点数没有这种正负不同的情况。</p>
</blockquote>
<h3 id="2-ensp-浮点数表示"><a href="#2-ensp-浮点数表示" class="headerlink" title="2.&ensp;浮点数表示"></a>2.&ensp;浮点数表示</h3><h4 id="2-1-ensp-IEEE浮点数表示"><a href="#2-1-ensp-IEEE浮点数表示" class="headerlink" title="2.1.&ensp;IEEE浮点数表示"></a>2.1.&ensp;IEEE浮点数表示</h4><p>小数二进制表示法和IEEE浮点数表示法都<strong>只能精确表示能被写成$x \times 2^y$的数，其他数只能被近似表示</strong>。与前者不同，IEEE浮点表示法可以
表示很大的数。</p>
<blockquote>
<p>IEEE浮点表示：$V=(-1)^s\times M\times 2^E$ <br>
其中，$M$是一个二进制小数，范围是$0\leq M &lt; 1$或者$1\leq M &lt;2$</p>
</blockquote>
<h4 id="2-2-ensp-单精度和双精度内存格式"><a href="#2-2-ensp-单精度和双精度内存格式" class="headerlink" title="2.2.&ensp;单精度和双精度内存格式"></a>2.2.&ensp;单精度和双精度内存格式</h4><p><img src="/img/books/csapp/chapter2/floatdouble.png" alt="float-double"></p>
<h4 id="2-3-ensp-IEEE浮点数重要设计理念"><a href="#2-3-ensp-IEEE浮点数重要设计理念" class="headerlink" title="2.3.&ensp;IEEE浮点数重要设计理念"></a>2.3.&ensp;IEEE浮点数重要设计理念</h4><blockquote>
<p>理念1：浮点数能够用整数排序函数来排序。当浮点数是正数时，它们按升序排列。</p>
</blockquote>
<blockquote>
<p>理念2：非规化浮点数平滑转换到规格化浮点数</p>
</blockquote>
<h4 id="2-4-ensp-IEEE浮点数设计"><a href="#2-4-ensp-IEEE浮点数设计" class="headerlink" title="2.4.&ensp;IEEE浮点数设计"></a>2.4.&ensp;IEEE浮点数设计</h4><h4 id="2-4-1-ensp-规格化浮点数"><a href="#2-4-1-ensp-规格化浮点数" class="headerlink" title="2.4.1.&ensp;规格化浮点数"></a>2.4.1.&ensp;规格化浮点数</h4><p><img src="/img/books/csapp/chapter2/IEEE-normalied.png" alt="normalied"></p>
<blockquote>
<p>阶码E被解释成以偏置格式表示的有符号整数，即$E=e-bias$</p>
</blockquote>
<p>其中，<em>$bias$可以推导出来</em>。</p>
<blockquote>
<p>尾数$M=1+frac$</p>
</blockquote>
<p><strong>这设计是为了2.3的理念2做准备，也可以获得一个额外精度位。</strong></p>
<h4 id="2-4-2-ensp-非规格化浮点数"><a href="#2-4-2-ensp-非规格化浮点数" class="headerlink" title="2.4.2.&ensp;非规格化浮点数"></a>2.4.2.&ensp;非规格化浮点数</h4><p><img src="/img/books/csapp/chapter2/IEEE-unnormalied.png" alt="unnormalied"></p>
<blockquote>
<p>阶码$E=1-bias$，尾数$M=frac$</p>
</blockquote>
<p><strong>这设计是为了遵循2.3的理念2</strong>。</p>
<h4 id="2-4-3-ensp-无穷大"><a href="#2-4-3-ensp-无穷大" class="headerlink" title="2.4.3.&ensp;无穷大"></a>2.4.3.&ensp;无穷大</h4><p><img src="/img/books/csapp/chapter2/IEEE-infinite.png" alt="infinite"></p>
<h4 id="2-4-4-ensp-NaN"><a href="#2-4-4-ensp-NaN" class="headerlink" title="2.4.4.&ensp;NaN"></a>2.4.4.&ensp;NaN</h4><p><img src="/img/books/csapp/chapter2/IEEE-NaN.png" alt="NaN">
其中，NaN也用来表示未初始化的数据。</p>
<h4 id="2-5-ensp-IEEE浮点数的数轴分布情况"><a href="#2-5-ensp-IEEE浮点数的数轴分布情况" class="headerlink" title="2.5.&ensp;IEEE浮点数的数轴分布情况"></a>2.5.&ensp;IEEE浮点数的数轴分布情况</h4><p><img src="/img/books/csapp/chapter2/IEEE-distribution.png" alt="IEEE-distribution">
可见，数值在-1.0 - 1.0 之间是均匀分布的，而越远离原点数值分布会变得越稀疏，但局部来看仍然是均匀分布。</p>
<h4 id="2-6-ensp-IEEE浮点数运算"><a href="#2-6-ensp-IEEE浮点数运算" class="headerlink" title="2.6.&ensp;IEEE浮点数运算"></a>2.6.&ensp;IEEE浮点数运算</h4><h4 id="2-6-1-ensp-偶数舍入"><a href="#2-6-1-ensp-偶数舍入" class="headerlink" title="2.6.1.&ensp;偶数舍入"></a>2.6.1.&ensp;偶数舍入</h4><p>IEEE的浮点数的舍入方式是偶数舍入。它会要求向最接近的值舍入，当它是个中间值时，这种舍入方式倾向使得最低有效数字是偶数，如果是二进制小数，它倾向使得最低有效位是零。</p>
<blockquote>
<p><font color="#800"><strong>警惕三：</strong>当一个数右移时，应该是直接截断（向零舍入）还是需要考虑后面的部分（偶数舍入）。
前者适用于补码，后者适用于浮点数。</font></p>
</blockquote>
<h4 id="2-6-2-ensp-IEEE浮点数运算"><a href="#2-6-2-ensp-IEEE浮点数运算" class="headerlink" title="2.6.2.&ensp;IEEE浮点数运算"></a>2.6.2.&ensp;IEEE浮点数运算</h4><p><strong>原理5: 浮点数运算</strong></p>
<blockquote>
<p>对实数$x，y$，有：
$$
    x \odot ^f y = Round(x \odot y)
$$
其中，$\odot$是定义在实数上的运算，$Round$是偶数舍入函数。</p>
</blockquote>
<h4 id="2-6-3-ensp-IEEE浮点数运算性质"><a href="#2-6-3-ensp-IEEE浮点数运算性质" class="headerlink" title="2.6.3.&ensp;IEEE浮点数运算性质"></a>2.6.3.&ensp;IEEE浮点数运算性质</h4><p>浮点加法满足可交换性，单调性即$a\geq b \Rightarrow x+a\geq x+b$。另方面因为精度和舍入问题，不满足结合性。</p>
<p>浮点乘法满足可交换性，单调性即
$$
a \geq b 且 c\geq 0 \Rightarrow a*^f c \geq b*^f c \\
a \geq b 且 c\leq 0 \Rightarrow a*^f c \leq b*^f c
$$
但缺乏结合性和分配性。</p>
<h4 id="2-7-ensp-c语言的浮点数类型转换"><a href="#2-7-ensp-c语言的浮点数类型转换" class="headerlink" title="2.7.&ensp;c语言的浮点数类型转换"></a>2.7.&ensp;c语言的浮点数类型转换</h4><p><img src="/img/books/csapp/chapter2/cast.png" alt="cast"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>integer</tag>
        <tag>floating-point number</tag>
      </tags>
  </entry>
  <entry>
    <title>myos(二)之屏幕输出函数</title>
    <url>/myos/printing-to-screen/</url>
    <content><![CDATA[<p>上章成功搭建了编写内核的工作环境，为了能跟内核进行初步的交互，紧接着要实现的便是内核的屏幕输出功能。</p>
<h3 id="2-1-ensp-屏幕输出的原理"><a href="#2-1-ensp-屏幕输出的原理" class="headerlink" title="2.1&ensp;屏幕输出的原理"></a>2.1&ensp;屏幕输出的原理</h3><p>为了在显示器显示文字，我们需要显卡的帮忙。显卡的作模式包括文本模式和图片模式，我们这里只讲简单的文本模式。既然显卡需要显示数据，这些数据肯定需要内存空间来存储。内存中存储显卡的数据的区域被称为显存，而物理内存的0xB8000-0xBFFFF这段内存区域映射了文本模式的显存。</p>
<p>计算机在加电自检后会自动将文本模式初始化为80*25的模式，在这种分辨率下，一个屏幕可以显示25行，一行显示80个字符。其中，每个字符占用了内存16 bits的空间，高8位定义了字符的backcolor和forecolor，后面8位存储这个字符的ascii码。它的结构如下：</p>
<p><img src="/img/myos/chapter-2_rbg.png" alt="rbg"></p>
<p>至于backcolor和forecolor字段什么值对应什么颜色，读者可以自己查阅资料。</p>
<p>除了这些显示的存储内容之外，我们还需要去使用显示的控制单元来完成一些特定的功能，比如设置光标的位置。为了读写这些控制单元，我们需要用到特殊的in/out指令来完成，这里将使用端口来作为内部寄存器的索引。</p>
<p><strong>在pc机上，0x3d4和0x3d5两个端口用来读写显卡的内部寄存器。</strong>其中，我们要往0x3d4端口写入要访问的寄存器编号，再通过0x3d5端口读写寄存器数据。</p>
<h3 id="2-2-ensp-屏幕输出的代码实现"><a href="#2-2-ensp-屏幕输出的代码实现" class="headerlink" title="2.2&ensp;屏幕输出的代码实现"></a>2.2&ensp;屏幕输出的代码实现</h3><h4 id="2-2-1-ensp-端口读写函数"><a href="#2-2-1-ensp-端口读写函数" class="headerlink" title="2.2.1&ensp;端口读写函数"></a>2.2.1&ensp;端口读写函数</h4><p>首先我们需要实现端口读写函数的实现，而c语言里面没有直接操作端口的方法，我们将借助c语言的内联汇编。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/////////////////端口读///////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span> <span class="title">inportb</span> <span class="params">(<span class="keyword">uint16_t</span> _port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> rv;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"inb %1, %0"</span> : <span class="string">"=a"</span> (rv) : <span class="string">"dN"</span> (_port));</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint16_t</span> <span class="title">inportw</span> <span class="params">(<span class="keyword">uint16_t</span> _port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> rv;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"inw %1, %0"</span> : <span class="string">"=a"</span> (rv) : <span class="string">"Nd"</span> (_port));</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////端口写///////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">outportb</span> <span class="params">(<span class="keyword">uint16_t</span> _port, <span class="keyword">uint8_t</span> _data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"outb %1, %0"</span> : : <span class="string">"dN"</span> (_port), <span class="string">"a"</span> (_data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">outportw</span> <span class="params">(<span class="keyword">uint16_t</span> _port, <span class="keyword">uint16_t</span> _data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"outw %1, %0"</span> : : <span class="string">"dN"</span> (_port), <span class="string">"a"</span> (_data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-ensp-宏定义、变量定义和函数原型"><a href="#2-2-2-ensp-宏定义、变量定义和函数原型" class="headerlink" title="2.2.2&ensp;宏定义、变量定义和函数原型"></a>2.2.2&ensp;宏定义、变量定义和函数原型</h4><p>接着，为了代码可读性，我们定义相关的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显卡文本模式的屏幕分辨率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SCREEN_ROW 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SCREEN_COL 80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文本模式显存的物理内存起始地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_START  0xb8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过0x3d4端口告知需要访问哪个显卡的寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_REGISTER_PORT 0x3d4</span></span><br><span class="line"><span class="comment">//通过0x3d5端口读写显卡的寄存器数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEO_DATA_PORT 0x3d5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存放光标的高8位的显卡寄存器编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUR_REG_HIGH   14</span></span><br><span class="line"><span class="comment">//存放光标的低8位的显卡寄存器编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUR_REG_LOW    15</span></span><br></pre></td></tr></table></figure>
<p>以及定义重要的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显卡文本模式显存的指针</span></span><br><span class="line"><span class="keyword">uint16_t</span>* video_pointer;</span><br><span class="line"><span class="comment">//光标的x,y坐标</span></span><br><span class="line"><span class="keyword">uint8_t</span>  x_cur=<span class="number">0</span>,y_cur=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//前景，背景的颜色，默认黑底白字</span></span><br><span class="line"><span class="keyword">uint16_t</span> text_color;</span><br></pre></td></tr></table></figure>

<p>屏幕输出操作的函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置指向文本模式显存的指针,以及清屏</span></span><br><span class="line"><span class="comment">//必须在使用console模块其他函数之前调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_video</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_screen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_text_color</span><span class="params">( <span class="keyword">text_color_t</span> backcolor,<span class="keyword">text_color_t</span> forecolor)</span></span>;</span><br><span class="line"><span class="comment">//重置输出文本的颜色，默认黑底白字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_test_color</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putch</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span>  <span class="keyword">char</span> * str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里为了直观，给出三个静态函数的原型，实际上在该文件并不用声明静态函数。</p>
<h4 id="2-2-3-ensp-光标位置更新"><a href="#2-2-3-ensp-光标位置更新" class="headerlink" title="2.2.3&ensp;光标位置更新"></a>2.2.3&ensp;光标位置更新</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//光标移动</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_cursor</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了一步步实现以上函数，我们需要实现作为基础的更新光标位置函数，它是一个静态函数，只在console模块里被使用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">udpate_cursor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//光标的一维线性位置</span></span><br><span class="line">    <span class="keyword">uint16_t</span> cursor_location= y_cur * MAX_SCREEN_COL + x_cur; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//光标位置的线性数据存放在两个显卡寄存器里，分别是它的高8位和低8位数据</span></span><br><span class="line"></span><br><span class="line">    outportb(CUR_REGISTER_PORT,CUR_REG_HIGH);   <span class="comment">//告知要操作光标的高8位寄存器</span></span><br><span class="line">    outportb(CUR_DATA_PORT,cursor_location&gt;&gt;<span class="number">8</span>); <span class="comment">//往高8位寄存器里写数据</span></span><br><span class="line"></span><br><span class="line">    outportb(CUR_REGISTER_PORT,CUR_REG_LOW);   <span class="comment">//告知要操作光标的低8位寄存器</span></span><br><span class="line">    outportb(CUR_DATA_PORT,cursor_location);   <span class="comment">//往低8位寄存器里写数据</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-ensp-清屏"><a href="#2-2-4-ensp-清屏" class="headerlink" title="2.2.4&ensp;清屏"></a>2.2.4&ensp;清屏</h4><p>说白了，清屏就是将文本模式的显存全部设置成空格符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_screen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>  t_color = colorcat(t_white, t_black);</span><br><span class="line">    <span class="comment">//空格符</span></span><br><span class="line">    <span class="keyword">uint16_t</span> blank = (t_color&lt;&lt;<span class="number">8</span>) | BLANK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将文本模式的显存全部设置成空格符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX_SCREEN_ROW * MAX_SCREEN_COL; i++)</span><br><span class="line">        video_pointer[i]=blank;</span><br><span class="line"></span><br><span class="line">    x_cur=y_cur=<span class="number">0</span>;</span><br><span class="line">    update_cursor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-ensp-屏幕滚动显示"><a href="#2-2-5-ensp-屏幕滚动显示" class="headerlink" title="2.2.5&ensp;屏幕滚动显示"></a>2.2.5&ensp;屏幕滚动显示</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//屏幕滚动显示</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scroll_screen</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>当字符占满屏幕时，屏幕就要向上滚动，以显示接下来的字符。简单地说，它的逻辑实际就是将后24行的数据全部向上挪动一行，最后一行清空：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scroll_screen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>  t_color = colorcat(t_white, t_black);</span><br><span class="line">    <span class="comment">//空格符</span></span><br><span class="line">    <span class="keyword">uint16_t</span> blank = (t_color&lt;&lt;<span class="number">8</span>) | BLANK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//光标到达最下方，该滚动屏幕</span></span><br><span class="line">    <span class="keyword">if</span> ( y_cur &gt;= MAX_SCREEN_ROW )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//将前面除了第一行外的所有行数据复制到上一行</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; MAX_SCREEN_ROW * MAX_SCREEN_COL - MAX_SCREEN_COL; i++)</span><br><span class="line">            video_pointer[i]=video_pointer[i+MAX_SCREEN_COL];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一行设置成空格符</span></span><br><span class="line">        <span class="keyword">for</span> (; i&lt; MAX_SCREEN_ROW * MAX_SCREEN_COL ;i++)</span><br><span class="line">            video_pointer[i]=blank;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//屏幕滚动一行，所以光标要向上移动一行</span></span><br><span class="line">        y_cur--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6-ensp-显示字符串"><a href="#2-2-6-ensp-显示字符串" class="headerlink" title="2.2.6&ensp;显示字符串"></a>2.2.6&ensp;显示字符串</h4><p>这部分重点在于实现putch函数，puts只是在其基础上重复输出。而putch函数一开始还是要识别出输出字符是可打印字符还是一些有特殊含义的字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putch</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> * char_location;</span><br><span class="line">    <span class="comment">/*Carriage Return*/</span></span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'\r'</span>)</span><br><span class="line">        x_cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x_cur=<span class="number">0</span>;</span><br><span class="line">        y_cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退格</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==BACKSPACE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x_cur&gt;<span class="number">0</span>)</span><br><span class="line">            x_cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Handles a tab by incrementing the cursor's x*/</span></span><br><span class="line">    <span class="comment">/*but only to a point that will make it divisible by 8*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c==TAB)</span><br><span class="line">        x_cur=(x_cur+<span class="number">8</span>)&amp;~(<span class="number">8</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//any charactor greater than and inclu-</span></span><br><span class="line">    <span class="comment">//ding a space  is a printfable charactor</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">' '</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        char_location= video_pointer + y_cur * MAX_SCREEN_COL + x_cur;</span><br><span class="line"></span><br><span class="line">        *char_location = c | (text_color&lt;&lt;<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        x_cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x_cur&gt;=MAX_SCREEN_COL)</span><br><span class="line">    &#123;</span><br><span class="line">        x_cur=<span class="number">0</span>;</span><br><span class="line">        y_cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有必要的话滚动屏幕</span></span><br><span class="line">    scroll_srceen();</span><br><span class="line">    <span class="comment">//更新光标位置</span></span><br><span class="line">    update_cursor();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span>  <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        putch(str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-7-ensp-printf函数"><a href="#2-2-7-ensp-printf函数" class="headerlink" title="2.2.7&ensp;printf函数"></a>2.2.7&ensp;printf函数</h4><p>前面已经实现了输出字符串的功能，但我们还缺少一个基本的格式化屏幕输出函数，下面一步步实现printf函数。首先我们看看调用printf函数时候堆栈会发生什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"these numbers are : %d,%d,%d,%d"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>这句话的汇编代码大概是这样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 4</span><br><span class="line">push 3</span><br><span class="line">push 2</span><br><span class="line">push 1</span><br><span class="line">push $0xaddr</span><br><span class="line">call printf</span><br><span class="line">sub esp,20</span><br></pre></td></tr></table></figure>
<p>根据cdecl约定，函数参数会依照从右到左的顺序入栈。上面$0xaddr代表字符串“these numbers are : %d,%d,%d,%d”的地址。在这之后它的栈内容是：</p>
<p><img src="/img/myos/chapter-2_stack.png" alt="stack"></p>
<p>上图的内存地址只是相对地址，指向格式化字符串的指针format string addr占用了4字节的空间。如果我们想将格式化字符串正确打印出来，换句话就是找到每个%d对应的值，必须根据内存栈正确处理printf的变长参数。我们这里用宏定义辅助：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* va_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让args_pointer指向变长参数的起始地址，format代表格式化字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(args_pointer,format) \</span></span><br><span class="line">    (args_pointer = (va_list)&amp;format + <span class="keyword">sizeof</span>(format) )</span><br><span class="line"><span class="comment">//返回当前参数的值，并让args_pointer指向下一个参数的地址,type表示当前参数的数据类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_args(args_pointer,type) \</span></span><br><span class="line">    (*(type*) ( (args_pointer + =<span class="keyword">sizeof</span>(type)) - <span class="keyword">sizeof</span>(type) ) )</span><br><span class="line"><span class="comment">//置为空指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(args_pointer) \</span></span><br><span class="line">    (args_pointer=(va_list)<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>上面的是va_start，va_args，va_end的简单版本实现。我们将它用在printf函数的代码里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];  <span class="comment">//将格式化字符串的%-形式的字符串替换成对应的值，处理后的字符串将存储在buff中</span></span><br><span class="line">    <span class="keyword">int</span> buff_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//list将指向可变参数列表的第一个参数</span></span><br><span class="line">    va_list <span class="built_in">list</span>;</span><br><span class="line">    va_start(<span class="built_in">list</span>,format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vsprintf将格式化字符串的%-形式的字符串替换成对应的值，将处理后的字符串存储在buff中</span></span><br><span class="line">    buff_index=<span class="built_in">vsprintf</span>(buff,format,<span class="built_in">list</span>); <span class="comment">//buf_index将表示存储在buff的字符串后面一位的下标。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//置为空指针</span></span><br><span class="line">    va_end(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出处理过的字符串</span></span><br><span class="line">    buff[buff_index]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">puts</span>(buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面很容易看出，vsprintf将是完成printf函数的关键。vsprintf的功能主要是将格式化字符串的%-形式的字符串替换成对应的值，将处理后的字符串存储在buff中。这里的vsprintf很简单，也仅仅实现了处理%d、%x、%c、%s的情况，以后有需要会增加其他情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将格式化字符串的%-形式的字符串替换成对应的值，将处理后的字符串存储在buff中</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param buff : 存储处理后的字符串</span></span><br><span class="line"><span class="comment"> * @param format : 格式化字符串，即待处理字符串</span></span><br><span class="line"><span class="comment"> * @param list :   指向可变参数列表里的参数的指针</span></span><br><span class="line"><span class="comment"> * @return int :   buff字符串末尾下一位的下标</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *buff,<span class="keyword">const</span> <span class="keyword">char</span>*format,va_list <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buff_index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> itoa_str[<span class="number">32</span>];          <span class="comment">//存放整型转换后的字符串</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>  int_value;             <span class="comment">//用于%d</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uint_value;    <span class="comment">//用于%x</span></span><br><span class="line">    <span class="keyword">char</span> char_value;            <span class="comment">//用于%c</span></span><br><span class="line">    <span class="keyword">char</span> * string_addr;         <span class="comment">//用于%s</span></span><br><span class="line">    <span class="comment">//顺序处理format字符串每一个字符</span></span><br><span class="line">    <span class="keyword">for</span>(; *format; format++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前字符是普通字符,直接复制</span></span><br><span class="line">        <span class="keyword">if</span>(*format!=<span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buff[buff_index++]=*format;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//当前字符是‘%’</span></span><br><span class="line">    format++;</span><br><span class="line">    <span class="keyword">switch</span>(*format)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//整型</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">                <span class="comment">//取出这个整型</span></span><br><span class="line">                int_value=va_args(<span class="built_in">list</span>,<span class="keyword">int</span>);</span><br><span class="line">                <span class="comment">//10进制转换</span></span><br><span class="line">                itoa(int_value,itoa_str,<span class="number">10</span>);</span><br><span class="line">                len=<span class="built_in">strlen</span>(itoa_str);</span><br><span class="line">                <span class="comment">//将转换后的字符串复制到buff上</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;buff[buff_index], itoa_str, len);</span><br><span class="line">                buff_index+=len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//字符</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">                <span class="comment">//注意，因为入栈用的push，即使是char变量，esp也要加4，所以不能用va_args(list,char)</span></span><br><span class="line">                char_value=va_args(<span class="built_in">list</span>,<span class="keyword">int32_t</span>);</span><br><span class="line">                buff[buff_index]=char_value;</span><br><span class="line">                buff_index++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//字符串</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                string_addr=va_args(<span class="built_in">list</span>,<span class="keyword">char</span>*);</span><br><span class="line">                len=<span class="built_in">strlen</span>(string_addr);</span><br><span class="line">                <span class="comment">//将字符串复制到buff上</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;buff[buff_index],string_addr,len);</span><br><span class="line">                buff_index+=len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//16进制</span></span><br><span class="line">            <span class="keyword">case</span><span class="number">'</span>x<span class="number">'</span>:</span><br><span class="line">                uint_value=va_args(<span class="built_in">list</span>,<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">                <span class="comment">//16进制转换</span></span><br><span class="line">                itoa(uint_value,itoa_str,<span class="number">16</span>);</span><br><span class="line">                len=<span class="built_in">strlen</span>(itoa_str);</span><br><span class="line">                <span class="comment">//将转换后的字符串复制到buff上</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;buff[buff_index], itoa_str, len);</span><br><span class="line">                buff_index+=len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不符合以上情况</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">//TODO panic</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//end of switch</span></span><br><span class="line">    &#125;<span class="comment">//end of for</span></span><br><span class="line">    <span class="keyword">return</span> buff_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-8-ensp-测试屏幕输出函数"><a href="#2-2-8-ensp-测试屏幕输出函数" class="headerlink" title="2.2.8&ensp;测试屏幕输出函数"></a>2.2.8&ensp;测试屏幕输出函数</h4><p>最后，我们在main函数测试下我们的console模块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_video();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* name=<span class="string">"binson"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello myos!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置成黑底红字</span></span><br><span class="line">    set_text_color( t_black, t_red  );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello myos!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The string \"%s\" has %d characters beginning with \'%c\',and its address is 0x%x\n"</span>, \</span><br><span class="line">            name,<span class="built_in">strlen</span>(name),name[<span class="number">0</span>],name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置颜色</span></span><br><span class="line">    reset_test_color();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"hello myos!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的效果如下：</p>
<p><img src="/img/myos/chapter-2_hello-myos.png" alt="hello-myos"></p>
<h3 id="2-3-ensp-文件目录结构以及变更"><a href="#2-3-ensp-文件目录结构以及变更" class="headerlink" title="2.3&ensp;文件目录结构以及变更"></a>2.3&ensp;文件目录结构以及变更</h3><p><img src="/img/myos/chapter-2_dir.png" alt="dir"></p>
<p>这里新增了一种文件状态描述符 r，代表rename操作。它的语法是 r&emsp;filename&emsp;:旧路径+旧文件名&emsp; -&gt; ./ ，其中filename是现在的文件名，旧路径会以/开头，表示此os项目的根目录，后面的-&gt; ./ 表示移动到当前目录。上面的 r&emsp;boot.s&emsp;/boot.s&emsp;-&gt; ./ 的意思就是从原来在项目根目录下的boot.s移动到当前目录下，而名字并没有改变。</p>
<p>还有就是dir和floppy.img这些文件起始也有变化，但我们这里只关注源码文件。</p>
]]></content>
      <categories>
        <category>operating system</category>
      </categories>
      <tags>
        <tag>myos</tag>
      </tags>
  </entry>
  <entry>
    <title>myos(一)之搭建环境</title>
    <url>/myos/environment-setup/</url>
    <content><![CDATA[<p><strong>本文假设你使用的是linux操作系统</strong>，使用windows的朋友可以建个虚拟机。如果读者觉得本系列课程有些关键的术语和知识点弄不懂，建议使用搜索引擎弄明白，或者看下《深入理解计算机系统》这本书打下坚实的基础。</p>
<h3 id="1-1-ensp-先写一个简单的内核"><a href="#1-1-ensp-先写一个简单的内核" class="headerlink" title="1.1&ensp;先写一个简单的内核"></a>1.1&ensp;先写一个简单的内核</h3><p>首先，我们需要先写个引导代码，这部分代码用的是intel风格汇编语言。这个boot.s的内容如下:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   boot.s -- 内核从这里开始</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; ----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Multiboot 魔数，由规范决定的</span></span><br><span class="line">MBOOT_HEADER_MAGIC  <span class="built_in">equ</span>     <span class="number">0x1BADB002</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 0 号位表示所有的引导模块将按页(4KB)边界对齐</span></span><br><span class="line">MBOOT_PAGE_ALIGN    <span class="built_in">equ</span>     <span class="number">1</span> &lt;&lt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 1 号位通过 Multiboot 信息结构的 mem_* 域包括可用内存的信息</span></span><br><span class="line"><span class="comment">; (告诉GRUB把内存空间的信息包含在Multiboot信息结构中)</span></span><br><span class="line">MBOOT_MEM_INFO      <span class="built_in">equ</span>     <span class="number">1</span> &lt;&lt; <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">; 定义我们使用的 Multiboot 的标记</span></span><br><span class="line">MBOOT_HEADER_FLAGS  <span class="built_in">equ</span>     MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO</span><br><span class="line"></span><br><span class="line"><span class="comment">; 域checksum是一个32位的无符号值，当与其他的magic域(也就是magic和flags)</span></span><br><span class="line"><span class="comment">; 相加时，要求其结果必须是32位的无符号值 0 (即magic+flags+checksum = 0)</span></span><br><span class="line">MBOOT_CHECKSUM      <span class="built_in">equ</span>     -(MBOOT_HEADER_MAGIC+MBOOT_HEADER_FLAGS)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 符合Multiboot规范的 OS 映象需要这样一个 magic Multiboot 头</span></span><br><span class="line"><span class="comment">; Multiboot 头的分布必须如下表所示：</span></span><br><span class="line"><span class="comment">; ----------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 偏移量  类型  域名        备注</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   0     u32   magic       必需</span></span><br><span class="line"><span class="comment">;   4     u32   flags       必需 </span></span><br><span class="line"><span class="comment">;   8     u32   checksum    必需 </span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; 我们只使用到这些就够了，更多的详细说明请参阅 GNU 相关文档</span></span><br><span class="line"><span class="comment">;-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;-----------------------------------------------------------------------------</span></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="comment">; 在代码段的起始位置设置符合 Multiboot 规范的标记</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dd</span> MBOOT_HEADER_MAGIC   <span class="comment">; GRUB 会通过这个魔数判断该映像是否支持</span></span><br><span class="line"><span class="built_in">dd</span> MBOOT_HEADER_FLAGS   <span class="comment">; GRUB 的一些加载时选项，其详细注释在定义处</span></span><br><span class="line"><span class="built_in">dd</span> MBOOT_CHECKSUM       <span class="comment">; 检测数值，其含义在定义处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;; GLOBAL extern;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line">[<span class="meta">GLOBAL</span> start]                  <span class="comment">; 内核入口</span></span><br><span class="line">[<span class="meta">EXTERN</span> main]                   <span class="comment">; c代码的入口</span></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;; start ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">  <span class="keyword">push</span>    <span class="built_in">ebx</span>                   <span class="comment">; ebx存放了multiboot头的内存地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; Execute the kernel:</span></span><br><span class="line">  <span class="keyword">cli</span>                         <span class="comment">; 禁止中断</span></span><br><span class="line">  <span class="keyword">call</span> main                   <span class="comment">; 调用c源码的main函数</span></span><br><span class="line">  <span class="keyword">jmp</span> $                       <span class="comment">; 进入无限循环</span></span><br></pre></td></tr></table></figure>
<p>因为我们暂时不准备写引导程序，而是使用现成的GRUB来引导。这个boot.s的1-34行就是跟GRUB的multiboot标准相关的代码，这部分不懂也不影响后面的内容，有兴趣的朋友可以自己查阅GRUB的multiboot标准的资料。</p>
<p>第49行便是内核的入口，当GRUB成功引导内核后，ebx寄存器存放的便是multiboot头的内存地址。在第52行里，这个文件便会调用外部的c文件的main函数，如果c函数返回的话，下一句的jmp $ 便会让内核进入无限循环。下面我们开始写c源码的文件main.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个c文件很简单，它的main函数一开始便返回。</p>
<p>在完成简单内核的编写后，接着我们新建一个Makefile文件，下面我们逐步会完善这个文件。到本章结束，我们只需要输入简单的语句，它就可以帮助我们完成编译、链接、运行、调试的过程。</p>
<h3 id="1-2-ensp-编译环境"><a href="#1-2-ensp-编译环境" class="headerlink" title="1.2&ensp;编译环境"></a>1.2&ensp;编译环境</h3><p>本操作系统大部分源码都是用c语言完成，我们将使用gcc来编译源代码。项目将使用汇编语言作为辅助，我们将使用nasm编译器来编译汇编(如果你机器下没有nasm，就先下载个)。下面我们在Makefile文件里添加相关编译语句:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC  = gcc</span><br><span class="line">ASM = nasm</span><br><span class="line"></span><br><span class="line">C_FLAGS   = -c -Wall -m32 -g -nostdinc -fno-builtin -fno-stack-protector</span><br><span class="line">ASM_FLAGS = -f elf -g -F stabs</span><br><span class="line"></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	@echo 编译代码文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(C_FLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="section">.s.o:</span></span><br><span class="line">	@echo 编译汇编文件 <span class="variable">$&lt;</span> ...</span><br><span class="line">	<span class="variable">$(ASM)</span> <span class="variable">$(ASM_FLAGS)</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>上面的语句帮助我们生成相关源文件的elf可重定位目标文件。</p>
<p>下面说说C_FLAGS和ASM_FlAGS两个变量中与本项目比较相关的选项。其中，-m32是告诉编译器帮助我们生成32位的可重定位目标文件，-nostdlibnc告诉编译器不使用系统的头文件，-fno-builtin则让编译器不使用C语言的内建函数。nasm 的 -f elf 是要输出elf可重定位目标文件，如果不指定输出文件格式，默认输出格式将是bin。</p>
<p>其他选项如果不懂的话可以通过“gcc –help”和”nasm –help”查询。</p>
<h3 id="1-3-ensp-链接环境"><a href="#1-3-ensp-链接环境" class="headerlink" title="1.3&ensp;链接环境"></a>1.3&ensp;链接环境</h3><p>我们将使用ld来链接上面步骤的可重定位目标文件，类似的，我们往Makefile文件添加以下语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LD &#x3D; ld</span><br><span class="line"></span><br><span class="line">LD_FLAGS &#x3D; -T scripts&#x2F;link.ld -m elf_i386 -nostdlib</span><br><span class="line"></span><br><span class="line">link:</span><br><span class="line">	@echo 链接内核文件...</span><br><span class="line">	$(LD) $(LD_FLAGS) $(S_OBJECTS) $(C_OBJECTS) -o Fredix</span><br></pre></td></tr></table></figure>
<p>“-nostdlib”告诉链接器仅搜索那些在命令行上显式指定的库路径。”-m elf_i386”要求生成i386的elf可执行文件。”-T”选项用于指定自定义的脚本文件，而链接器将会使用这个脚本定义的规则来精确控制目标文件的格式。这里，链接器则使用位于子目录scripts的link.ld文件。它的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRY(start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*段起始位置*&#x2F;</span><br><span class="line">	. &#x3D; 0x100000;</span><br><span class="line"></span><br><span class="line">	.text :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.data :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.data)</span><br><span class="line">		*(.rodata)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.bss :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.bss)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stab :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stab)</span><br><span class="line">		. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	.stabstr :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.stabstr)</span><br><span class="line">	 	. &#x3D; ALIGN(4096);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;DISCARD&#x2F; : &#123; *(.comment) *(.eh_frame) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这脚本首先告诉链接器程序的入口在‘start’符号处,接着第一个段是.text段，它的起始位置是0x100000(即内存1MB处)，接着便是存放初始化数据的.data段和未初始化数据段的.bss段。linux gcc会增加一个额外的只读初始化数据段的.rodata段，为了方便，我们将它放在.data段里面。后面的.stab和.stabstr段存放的是调试相关的信息。</p>
<h3 id="1-4-ensp-内核映像"><a href="#1-4-ensp-内核映像" class="headerlink" title="1.4&ensp;内核映像"></a>1.4&ensp;内核映像</h3><p>上面步骤的链接器会生成一个名称为Fredix的可执行文件。我们会将这个可执行文件放进一个内核映像中，这样我们就可以使用虚拟机来运行我们的内核了。</p>
<p>前面说过，我们将直接使用GRUB来引导我们的内核。本项目提供了一个有着GRUB模块的floppy.img的映像文件，大家可以在我的<a href="https://github.com/wubinson/binux" target="_blank" rel="noopener">github</a>里下载。一开始这个映像文件并没有内核的可执行文件，所以我们需要在Makefile文件里添加以下语句，来往img文件放置内核文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:update_image</span><br><span class="line">update_image:</span><br><span class="line">	sudo mount floppy.img &#x2F;mnt&#x2F;</span><br><span class="line">	sudo cp Fredix &#x2F;mnt&#x2F;Fredix</span><br><span class="line">	sleep 1</span><br><span class="line">	sudo umount &#x2F;mnt</span><br></pre></td></tr></table></figure>
<p>上面的语句只是将几条步骤捆绑起来，我们完全可以手动一条条地完成。</p>
<p>需要注意的是，如果读者想给自己的内核取个不一样的名字，除了需要改掉链接步骤和update_image步骤的Fredix，还需要修改img文件里的boot/grub/grub.conf文件和/boot/grub/menu.lst文件(步骤类似上面，先挂载，再修改)。它们的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title&#x3D;Fredix</span><br><span class="line">root (fd0)</span><br><span class="line">kernel &#x2F;Fredix</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 1</span><br><span class="line"></span><br><span class="line">title    Fredix	</span><br><span class="line">	root (fd0)</span><br><span class="line">	kernel &#x2F;Fredix</span><br><span class="line"></span><br><span class="line">module &#x2F;modules&#x2F;hello</span><br></pre></td></tr></table></figure>
<p>由于篇幅有限，这里并没有写出Makefile的全部内容，具体情况请看github的文件。这时，我们在终端输入”make”之后，便会自动完成编译，链接和制造内核映像的过程。</p>
<h3 id="1-5-ensp-运行环境"><a href="#1-5-ensp-运行环境" class="headerlink" title="1.5&ensp;运行环境"></a>1.5&ensp;运行环境</h3><p>有了内核映像之后，我们需要一个虚拟机来运行我们的内核，可以选择bochs或qemu，这里选择qemu来运行。于是我们往Makefile添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:qemu</span><br><span class="line">qemu:</span><br><span class="line">	qemu-system-i386 -fda floppy.img -boot a</span><br></pre></td></tr></table></figure>
<p>接着输入“make qemu”,如果没有什么错误的话，将会出现下图：</p>
<p><img src="/img/myos/chapter-1_runtime.png" alt="runtime"></p>
<h3 id="1-6-ensp-调试环境"><a href="#1-6-ensp-调试环境" class="headerlink" title="1.6&ensp;调试环境"></a>1.6&ensp;调试环境</h3><p>我们将用gdb调试内核，第一步骤往Makefile添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:debug</span><br><span class="line">debug:</span><br><span class="line">	qemu-system-i386 -S -s -fda floppy.img -boot a &amp;</span><br><span class="line">	sleep 1</span><br><span class="line">	gdb -tui -x scripts&#x2F;gdbinit</span><br></pre></td></tr></table></figure>
<p>上面多出来的-s跟-gdb tcp::1234的意义一样,也就是监听1234端口，等待gdb的连接，-S表示CPU将在开始时暂停，用c命令才能继续运行。第三句的gdb启动时将运行gdbinit脚本，以下是他的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file Fredix</span><br><span class="line">target remote :1234</span><br><span class="line">break main</span><br><span class="line">set disassembly-flavor intel</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>第一句加载我们的内核文件并获取符号表，接着连接1234端口，在main函数设置断点，用汇编语言风格设置为intel，最后的c是continue的意思。</p>
<p>接着我们仅需要输入“make debug”就可以进入gdb界面调试我们的程序。</p>
<p><img src="/img/myos/chapter-1_gdb.png" alt="gdb"></p>
<h3 id="1-7-ensp-文件目录结构以及变更"><a href="#1-7-ensp-文件目录结构以及变更" class="headerlink" title="1.7&ensp;文件目录结构以及变更"></a>1.7&ensp;文件目录结构以及变更</h3><p>至此，我们的基本环境就已经搭建好了，下面给出当前的目录结构：</p>
<p><img src="/img/myos/chapter-1_dir.png" alt="dir"></p>
<p>上图的+表示刚刚创建，后面还有！表示修改过，如果读者想对比两个文件有何不同，推荐使用meld。</p>
]]></content>
      <categories>
        <category>operating system</category>
      </categories>
      <tags>
        <tag>myos</tag>
      </tags>
  </entry>
  <entry>
    <title>myos(三)之断言</title>
    <url>/myos/assert/</url>
    <content><![CDATA[<p>断言是在防御性编程里面占据了非常重要地位的技巧，它们帮助你较早、较轻易地发现错误，使调试过程效率更高。我们用断言来检测程序正常运行时某一个条件是否总为真，它能让错误在运行时刻暴露在程序员面前。</p>
<h3 id="3-1-ensp-debug版本和release版本"><a href="#3-1-ensp-debug版本和release版本" class="headerlink" title="3.1&ensp;debug版本和release版本"></a>3.1&ensp;debug版本和release版本</h3><p>一般来说，因为断言多用于程序的debug版本里，所以后面我们要开始区分debug版本和release版本。debug版本使用断言，它的可执行文件中包含了调试信息的.debug节；release版本则没有这些调试信息，还还可以采用优化选项来优化代码。</p>
<p>我们修改Makefile文件，这样就可以根据情况生成debug版本和release版本：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#控制debug的开关，1 表示生成debug版本，0 表示生成release版本</span></span><br><span class="line">debug_switch = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(debug_switch)</span>,1)</span><br><span class="line">	<span class="comment">#debug</span></span><br><span class="line">	C_FLAGS = -c -Wall -m32 -g -fno-builtin -fno-stack-protector -I <span class="keyword">include</span></span><br><span class="line">	ASM_FLAGS = -f elf -g -F stabs</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	<span class="comment">#release</span></span><br><span class="line">	C_FLAGS = -c -Wall -m32  -fno-builtin -fno-stack-protector -I <span class="keyword">include</span> -D NDEBUG</span><br><span class="line">	ASM_FLAGS = -f elf -F stabs</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>上面的代码添加了一个控制是否debug的开关，当需要生成debug版本的时候，C_FLAGS和ASM_FLAGS后面会有-g选项；相反，当需要生成release版本，两者都没有-g选项，而且会要求编译器定义一个NDEBUG的宏。</p>
<h3 id="3-2-ensp-定义assert的宏"><a href="#3-2-ensp-定义assert的宏" class="headerlink" title="3.2&ensp;定义assert的宏"></a>3.2&ensp;定义assert的宏</h3><p>接下来，我们在头文件定义了assert的宏:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// not debugging, do nothing</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> assert(cond,info)    ( (void)0 )</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//debugging</span></span><br><span class="line">    #define assert(cond,info)         \</span><br><span class="line">        <span class="keyword">if</span>(!(cond))                   \</span><br><span class="line">        &#123;                             \</span><br><span class="line">          panic(info);                \</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//NDEBUG</span></span></span><br></pre></td></tr></table></figure>
<p>如果定义NDEBUG宏的话，程序将什么都不做。否则会判断cond这个条件是否为真，如果是假的话，将使用panic函数来打印出错处的函数调用栈以及其他信息，比如函数所在的文件和行数，并在输出信息最后中断程序。</p>
<h3 id="3-3-ensp-打印函数调用栈的实现原理"><a href="#3-3-ensp-打印函数调用栈的实现原理" class="headerlink" title="3.3&ensp;打印函数调用栈的实现原理"></a>3.3&ensp;打印函数调用栈的实现原理</h3><p>接下来，我们当然是想实现这个panic函数。但首先我们需要知道它的输出大概是什么样子，才能据此实现它的功能。举个例子，它的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x0010113C</span>] panic (src/kernel/driver/console.c at <span class="built_in">line</span> <span class="number">220</span>)</span><br><span class="line">[<span class="number">0x0010117C</span>] <span class="built_in">vsprintf</span> (src/kernel/driver/console.c at <span class="built_in">line</span> <span class="number">239</span>)</span><br><span class="line">[<span class="number">0x001011E0</span>] <span class="built_in">printf</span> (src/main.c at <span class="built_in">line</span> <span class="number">13</span>)</span><br><span class="line">Entry function : main</span><br></pre></td></tr></table></figure>
<p>输出部分包括了函数调用栈里每一个函数被调用时的内存地址（<strong>后面统一称为calling address</strong>），函数名，被调用时所在的文件名以及行数。下面将这四项拆开仔细讲解。</p>
<h4 id="3-3-1-ensp-函数被调用时的内存地址"><a href="#3-3-1-ensp-函数被调用时的内存地址" class="headerlink" title="3.3.1&ensp;函数被调用时的内存地址"></a>3.3.1&ensp;函数被调用时的内存地址</h4><p>此项是上面4项中最重要的，需要知道这个calling address才查得到其他3项。如果我们想拿到它，我们首先应该理解函数调用时的重要机制：<strong>调用者先将参数压栈，再将返回的地址压栈，接着执行call 0xaddr 这条调用指令</strong>。被调用者一开始会先执行以下两行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov  esp,ebp</span><br></pre></td></tr></table></figure>
<p>此时，局部的栈空间如下所示：</p>
<p><img src="/img/myos/chapter-3_stack.png" alt="stack"></p>
<p>从上图可以看出，在栈空间里，紧接着返回地址的下面是旧ebp的值，在mov esp,ebp 这语句之后，ebp就会指向栈里如图所示的位置。所以，我们可以通过读取ebp的值，再将ebp的值加上4 (<em>旧ebp的值占用了4字节</em>) ,便可得到指向返回地址的指针。</p>
<p>再者，call 0xaddr这条指令占了5个字节，因为call指令本身占了一字节，函数地址0xaddr占了4字节。所以，我们将返回地址减去5便得到calling address。</p>
<p>目前我们只拿到一个calling address，既然我们需要打印函数调用栈，所以还需要调用栈里面其它所有calling address。解决问题关键之处在于上图的旧ebp之上。下面的图能够帮助读者更直观地了解：</p>
<p><img src="/img/myos/chapter-3_ebp.png" alt="ebp"></p>
<p>假设我们现在拿到的是 $ebp_n$ ，那我们可以利用这个指针取出$ebp_{n-1}$的值，以此类推，我们可以往上取出调用栈所有的calling address。在这个循环里，我们取到内核入口函数Entry function即main函数这层便结束。</p>
<h4 id="3-3-2-ensp-函数名"><a href="#3-3-2-ensp-函数名" class="headerlink" title="3.3.2&ensp;函数名"></a>3.3.2&ensp;函数名</h4><p>接着，我们要根据calling address得到所对应的函数名。</p>
<p>在elf文件里有一个称作.symtab的节段，这个section实质是一个表，包含众多的表项，每个表项代表一个符号，它的数据结构可以表达成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> st_name;</span><br><span class="line">    <span class="keyword">uint16_t</span> st_value;</span><br><span class="line">    <span class="keyword">unti16_t</span> st_size;</span><br><span class="line">    <span class="keyword">uint8_t</span>  st_info;</span><br><span class="line">    <span class="keyword">uint8_t</span>  st_other;</span><br><span class="line">    <span class="keyword">uint16_t</span> st_shndx;</span><br><span class="line">&#125; <span class="keyword">elf32_symbol_t</span>;</span><br></pre></td></tr></table></figure>
<p>之所以特别表明elf32，是因为elf64下对应的数据结构会不一样。我们看下里面重要的变量。</p>
<p>st_name是这个符号在.strtab节的偏移量，就是说，我们需要.strtab的首地址和st_name这个偏移才能得到符号名。st_value在elf可执行文件里面是一个虚拟内存地址，如果这符号是函数的话，这个值在这里代表这个函数的内存起始地址，st_size也就代表了函数占用的字节大小。st_info用于判断这个符号的类型，比如函数或变量。</p>
<p>根据上面的数据结构，首先，我们筛选出函数类型的符号，再看上一节得到的calling address是不是在符号的地址区间$[st\_value,st\_value+st\_size)$之中。如果在这个区间里面，那么calling address就是属于这个函数的。</p>
<p>这样，我们便在查找函数名的过程里前进了一大步。现在的问题变成，我们要怎么得到.strtab和.symtab的首地址呢?</p>
<p>幸运的是，在GRUB引导我们的内核时，它会将一些重要的section信息加载进一个类型为multiboot_t的数据结构里，它里面有4个变量跟section信息相关：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> num;</span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> addr;</span><br><span class="line"><span class="keyword">uint32_t</span> shstrndx;</span><br></pre></td></tr></table></figure>
<p>其中，addr是节头部表（section header table）的地址，mun和size是section header table表项的数量和大小，shstrndx是段表字符串节(.shstrtab节)在section header table的索引，用于寻找.shstrtab节的首地址，而.shstrtab节用于存放各section的名字字符串。</p>
<p>每个section header都有一个变量sh_name，与上面的st_name类似，它仅是一个偏移量，结合它和.shstrtab的首地址才能找到该section 的节名称。因此，我们可以通过找section的名字，一对比便可以找到.strtab和.symtab的section header。在section header里的变量sh_addr便是它们的首地址。</p>
<h4 id="3-3-3-ensp-函数被调用时所在的文件名"><a href="#3-3-3-ensp-函数被调用时所在的文件名" class="headerlink" title="3.3.3&ensp;函数被调用时所在的文件名"></a>3.3.3&ensp;函数被调用时所在的文件名</h4><p>这部分需要借助.debug_info节段，.debug_info节需要编译器开启-g选项才能生成。linux下包括调试信息的节，包括.debug_info和后面的.debug_line，都遵循DWARF（<strong>Debugging With Attributed Record Formats</strong>）格式的设计。.debug_info节里面包含了核心DWARF数据，基本包含了如函数、参数、变量、类型等等大部分信息。</p>
<p>如果我们只想单纯地找到函数被调用时的文件名，其实并不一定需要.debug_info信息，我们仅仅凭借3.3.4小节的.debug_line节便可以完成。但我们借助.debug_info加载的信息可以较快速，优雅地完成3.3.4任务(可以从代码看出)。</p>
<p>.debug_info节包含了较详细的调试信息，但仅仅为了完成panic的功能，我们仅仅需要其中小部分的信息，debug_info节包含了很多Compilation Units（CU），每个CU对应一个源码文件，基本包括了一个源文件内部的如函数、参数、变量、类型等信息。这些函数，变量等都可以用debugging information entrie（DIE）来描述，每个DIE都包含了相关的标签和属性。</p>
<p>我们仅需要关注.debug_info的每一个CU头，以及CU的第一个DIE。因为第一个DIE描述了这个源文件的包括文件路径名和文件的内存范围的信息。</p>
<p>.debug_info的CU头的数据结构是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elf32_debug_info_CU_header_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> length;  <span class="comment">//CU_size + CU_header_size - sizeof(length)</span></span><br><span class="line">	<span class="keyword">uint16_t</span> version;</span><br><span class="line">	<span class="keyword">uint32_t</span> abbrev_offset;</span><br><span class="line">	<span class="keyword">uint8_t</span> pointer_size;</span><br><span class="line">&#125; __attribute__((packed)) elf32_debug_info_CU_header_t;</span><br></pre></td></tr></table></figure>
<p>这里面对我们最重要的就是与CU大小有联系的length变量，它帮助我们遍历每一个CU。还有就是，因为系统是32位系统，所以pointer_size是4，表示占用了4个字节。</p>
<p>第一个DIE的数据结构是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elf32_debug_info_file_DIE_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> abbrev_num;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_producer;</span><br><span class="line">	<span class="keyword">uint8_t</span> DW_AT_language;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_name; 		<span class="comment">//filename 偏移量</span></span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_comp_dir;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_low_pc; 		<span class="comment">//起始内存地址</span></span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_high_pc;</span><br><span class="line">	<span class="keyword">uint32_t</span> DW_AT_stmt_list;</span><br><span class="line">&#125;__attribute__((packed))  elf32_debug_info_file_DIE_t;</span><br></pre></td></tr></table></figure>
<p>这部分对我们重要的是DW_AT_name，DW_AT_low_pc和DW_AT_high_pc。其中DW_AT_name表示源文件的文件名在.debug_str节的偏移（所以还需要.debug_str节才能找到名字）。DW_AT_low_pc表示源文件的起始内存地址。</p>
<p>当call adress在$[DW\_AT\_low\_pc,DW\_AT\_low\_pc+DW\_AT\_high\_pc)$区间里，就表示这个地址在这源文件的内存范围里。于是，我们就取出该文件的文件名。</p>
<h4 id="3-3-4-ensp-函数被调用时的行数"><a href="#3-3-4-ensp-函数被调用时的行数" class="headerlink" title="3.3.4&ensp;函数被调用时的行数"></a>3.3.4&ensp;函数被调用时的行数</h4><p>接下来，我们就开始寻找函数被调用时所在的行数，这得借助elf文件的.debug_line节。它里面包含的信息可以确定源码的内存地址所对应的行数。想弄懂下面的内容的读者最好粗略看看<a href="http://dwarfstd.org/doc/DWARF4.pdf" target="_blank" rel="noopener">DWARF4的官方文档</a>的6.2小节。</p>
<p>类似地，.debug_line节也由很多CU组成。每个CU有一个CU头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elf32_debug_line_CU_heaher_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;  <span class="comment">//CU_size + CU_header_size - sizeof(length)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> header_length;</span><br><span class="line">    <span class="keyword">uint8_t</span>  min_instruction_length;</span><br><span class="line">    <span class="keyword">uint8_t</span>  default_is_stmt;</span><br><span class="line">    <span class="keyword">int8_t</span>   line_base;</span><br><span class="line">    <span class="keyword">uint8_t</span>  line_range;</span><br><span class="line">    <span class="keyword">uint8_t</span>  opcode_base;</span><br><span class="line">    <span class="keyword">uint8_t</span>  std_opcode_lengths[<span class="number">12</span>];</span><br><span class="line">&#125; __attribute__((packed)) elf32_debug_line_CU_header_t;</span><br></pre></td></tr></table></figure>
<p>这数据结构对我们比较有用的变量是min_instruction_length、line_base、line_range和opcode_base，这几个变量对文章后面的一种重要操作有决定性的作用，但它们的含义并不重要。</p>
<p>紧紧挨着CU头的便是记录了该源文件相关的目录及其文件名的信息。首先是目录信息，一开始是第一个目录，名字字符串在内存中以ascii码十六进制的形式存储。每一目录的字符串都以0x00字节结束。当整个目录信息结束时，它会以另一个0x00结尾。文件名的信息与目录信息的情况类似，除了还提供这文件在哪个目录下等额外信息。下面看个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">The Directory <span class="title">Table</span> <span class="params">(offset <span class="number">0x13a</span>)</span>:</span></span><br><span class="line"><span class="function"> 1	kernel</span></span><br><span class="line"> 2	./lib</span><br><span class="line"></span><br><span class="line"><span class="function">The <span class="built_in">File</span> Name <span class="title">Table</span> <span class="params">(offset <span class="number">0x148</span>)</span>:</span></span><br><span class="line"><span class="function"> Entry	Dir	Time	Size	Name</span></span><br><span class="line"> 1	1	0	0	heap.c</span><br><span class="line"> <span class="number">2</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">0</span>	libc.h</span><br></pre></td></tr></table></figure>
<p>上面的信息说明heap.c在kernel目录下，libc.h在./lib目录下，而heap.c源文件include了libc.h头文件。我们看看它对应的.debug_line信息内存数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x6B65726E</span> <span class="number">656</span>C00: <span class="string">"kernel"</span> (first directory)</span><br><span class="line"><span class="number">0x2E2F6C69</span> <span class="number">6200</span>: <span class="string">"./lib"</span> (second directory)</span><br><span class="line"><span class="number">0x00</span>: <span class="built_in">end</span> of the directories</span><br><span class="line"><span class="number">0x68656170</span> <span class="number">2E6300</span>: <span class="string">"heap.c"</span> (first file)</span><br><span class="line"><span class="number">0x010000</span>: Dir=<span class="number">1</span> (<span class="string">"kernel"</span>), Time=<span class="number">0</span>, Size=<span class="number">0</span></span><br><span class="line"><span class="number">0x6C696263</span> <span class="number">2E6800</span>: <span class="string">"libc.h"</span> (second file)</span><br><span class="line"><span class="number">0x020000</span>: Dir=<span class="number">2</span> (<span class="string">"./lib"</span>), Time=<span class="number">0</span>, Size=<span class="number">0</span></span><br><span class="line"><span class="number">0x00</span>: <span class="built_in">end</span> of the files</span><br></pre></td></tr></table></figure>
<p>CU剩余部分都是三个操作的内容：Standard opcodes，Extended opcodes 和 Special opcodes。当开头的第一个字节大小在1-12之间，表示是Standard opcodes；如果是0，则是Extended opcodes；最后如果是大于等于13，则是special opcodes。</p>
<p>在三者之中，special opcodes会直接改变地址寄存器和行寄存器的值。它改变地址和行数寄存器的方式是：</p>
<p>$$ \begin{equation} \begin{split} 
&amp;pc+=\frac{Opcode-Opcode\_base}{Line\_base}  * Min\_instruction\_length \\
&amp;line += Line\_base + (Opcode - Opcode\_base)\% Line\_range 
\end{split} \end{equation} $$
上面的Opcode便是我们的special opcodes码，公式右边的其他变量全是CU头里面定义的变量。</p>
<p>除了special opcodes，我们还需要关注Standard opcodes的DW_LNS_advance_pc、DW_LNS_advance_line、DW_LNS_const_add_pc这些操作，以及Extended opcodes的DW_LNE_set_address操作。这些操作都改变内存寄存器或行数寄存器。当然，为了完成整个解析过程，我们还需要看看其他操作。除了前面提到的，我们的代码暂时还考虑了Standard op的DW_LNS_copy、DW_LNS_negate_stmt以及Extended op的DW_LNE_SET_DISCRIMINATOR、DW_LNE_END_SEQUENCE.</p>
<p>现在假设解析完了第i条opcode，当前内存和行数寄存器的值分别是$pc_i$和$line_i$。那么当解析完第i+1条opcode后，它们将是$pc_{i+1}$ 和 $line_{i+1}$。它们之间的关系是：</p>
<p>$$
pc_{i+1}=pc_i+\Delta pc
$$</p>
<p>$$
line_{i+1}=line_i+\Delta line
$$</p>
<p>在这里，$\Delta pc$和$\Delta line$都可以是0。当我们发现$pc_{i+1}$第一次大于我们之前取得的calling address，那么$line_i$就是我们要找的行数（<strong>当然，前提是我们已经确定该调用地址就在这个CU代表的源文件里</strong>）。</p>
<h3 id="3-4-ensp-打印函数调用栈的实现"><a href="#3-4-ensp-打印函数调用栈的实现" class="headerlink" title="3.4&ensp;打印函数调用栈的实现"></a>3.4&ensp;打印函数调用栈的实现</h3><p>由于篇幅有限，这里将比较少涉及到实现细节。</p>
<h4 id="3-4-1-ensp-panic函数的骨架"><a href="#3-4-1-ensp-panic函数的骨架" class="headerlink" title="3.4.1&ensp;panic函数的骨架"></a>3.4.1&ensp;panic函数的骨架</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">panic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ebp, *return_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有初始化debug信息的话</span></span><br><span class="line">    <span class="keyword">if</span>(!is_debug_initialized)</span><br><span class="line">    &#123;</span><br><span class="line">        init_debug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------- System panic:%s ------\n"</span>,msg);</span><br><span class="line">    <span class="comment">//得到当前ebp寄存器的值</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"mov %%ebp, %0"</span> : <span class="string">"=r"</span> (ebp))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回地址=ebp指向的内存地址+4字节</span></span><br><span class="line">        return_addr = ebp + <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call 0xaddr 占了五字节</span></span><br><span class="line">        call_addr = *return_addr - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找函数名</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.debug_info</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.debug_line</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上一层函数栈的ebp</span></span><br><span class="line">        ebp=(<span class="keyword">uint8_t</span>*)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//halt</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>panic首先看系统之前有没有初始化过调试信息、得到过elf节段关键信息，接着内嵌汇编语句得到ebp的值，这样便可以顺藤摸瓜找到函数栈里上一层函数的returning address和calling address，利用这个地址查找函数名，所在文件名和行数，再依次找到再上一层的被调用地址，并重复以上的操作。</p>
<p>init_debug函数会调用load_elf()函数加载elf节段的信息。</p>
<h4 id="3-4-2-ensp-load-elf函数"><a href="#3-4-2-ensp-load-elf函数" class="headerlink" title="3.4.2&ensp;load_elf函数"></a>3.4.2&ensp;load_elf函数</h4><p>这阶段的load_elf暂时只为了实现assert功能，也就是只加载.strtab、.symtab、.debug_info、.debug_str和.debug_line节段。后面如果有其它需要才继续细化load_elf函数。</p>
<p>拿到elf各个节段的内存地址，我们必须借助前面提到的multiboot_t数据类型。grub模块会将相关信息存放在这个数据结构里，并将指向这结构的指针存放在ebx寄存器里。因为在boot.s里，我们在调用main函数里将ebx压入栈内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">  push    ebx                   ; ebx存放了multiboot头的内存地址</span><br><span class="line">  ; Execute the kernel:</span><br><span class="line">  cli                         ; 禁止中断</span><br><span class="line">  call main                   ; 调用c源码的main函数</span><br><span class="line">  jmp $                       ; 进入无限循环</span><br></pre></td></tr></table></figure>
<p>根据参数入栈的原理，我们需要在main函数里增加multiboot_t*类型的参数，并且在main函数内赋值给全局的g_multiboot_p指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">multiboot_t</span> * _multiboot_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    g_multiboot_p=_multiboot_p;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是load_elf()函数的骨架：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 multiboot_t 结构获取ELF信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_elf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// section headers</span></span><br><span class="line">    <span class="keyword">elf32_section_header_t</span> *sh = (<span class="keyword">elf32_section_header_t</span> *)g_multiboot_p-&gt;addr;</span><br><span class="line">    <span class="comment">//.shstrab节存储了sections的名称字符串</span></span><br><span class="line">    <span class="keyword">uint32_t</span> shstrtab = sh[g_multiboot_p-&gt;shstrndx].sh_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历每一个section header</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_multiboot_p-&gt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *section_name = (<span class="keyword">const</span> <span class="keyword">char</span> *)(shstrtab + sh[i].sh_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".strtab"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".symtab"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".debug_info"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".debug_str"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section_name, <span class="string">".debug_line"</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载后，panic函数便可以进去while循环开始解析各个section，这过程的原理上面已经大体讲完，由于有不少的细节，这里就不再一一讲述。</p>
<p>当我们在panic的骨架上添加完细节，整个断言部分便已经完成了。</p>
<h3 id="3-5-ensp-文件目录结构以及变更"><a href="#3-5-ensp-文件目录结构以及变更" class="headerlink" title="3.5&ensp;文件目录结构以及变更"></a>3.5&ensp;文件目录结构以及变更</h3><p><img src="/img/myos/chapter-3_dir.png" alt="dir"></p>
]]></content>
      <categories>
        <category>operating system</category>
      </categories>
      <tags>
        <tag>myos</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ primer笔记之 变量和基本类型</title>
    <url>/note/c++%20primer/chapter2-variables%20and%20basic%20types/</url>
    <content><![CDATA[<h3 id="1-章节一的笔记"><a href="#1-章节一的笔记" class="headerlink" title="1.章节一的笔记"></a>1.章节一的笔记</h3><p>因为章节一的笔记比较少，所以和章节二的笔记放在一起。</p>
<p>1）C++的endl是一个被称为操作符(manipulator)的特殊值。写入endl可以将与设备关联的缓冲区中的内容刷到设备中。
所以，cout &lt;&lt;endl 和 cout&lt;&lt;”\n”&lt;&lt;flush 是等价的。  </p>
<p>在标准输出定向到终端时，c语言的printf的缓冲区缺省为行缓冲区，所以会立即显示包含换行符的字符串。
当定向到文件时，缓冲区缺省为块缓冲，只有当缓冲区满后再刷新到文件上。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"cout endl"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"printf\n"</span>);</span><br><span class="line">_exit(<span class="number">0</span>);  <span class="comment">//不清理缓冲区退出</span></span><br></pre></td></tr></table></figure>
<p>上面这条程序如果标准输出是终端时，输出将会是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout endl</span><br><span class="line">printf</span><br></pre></td></tr></table></figure>
<p>如果标准输出定向到文件，输出将会是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout endl</span><br></pre></td></tr></table></figure>
<p>2）<strong>程序员在调试时常常会添加打印语句，这类语句应该保证”一直”刷新流。</strong>否则，如果程序崩溃，输出还会保留在缓冲区里,
从而导致关于程序崩溃位置的错误判断。</p>
<p>3）与输出运算符一样，输入运算符(&gt;&gt;)返回其左侧运算对象。所以 cin &gt;&gt; v1 &gt;&gt; v2  和 (cin &gt;&gt; v1) &gt;&gt; v2  是等价的。</p>
<p>4）当使用istream对象作为判断条件时，其效果是检测流的状态。如果遇到文件结束符，或遇到无效的输入，istream对象
会变成无效，这时判断条件为false。</p>
<h3 id="2-基本内置类型"><a href="#2-基本内置类型" class="headerlink" title="2.基本内置类型"></a>2.基本内置类型</h3><p>1）可寻址的最小内存块称为”字节” ，<strong>存储的基本单元称为”字”</strong>。大多数机器的字节由8 bits组成，<strong>字则由32位或
64位比特构成</strong>。</p>
<p>2）算术表达式中不要使用char或bool。<strong>因为char在一些机器上是有符号的，在另外一些机器上却是无符号的</strong>。</p>
<p>3）避免将int的尺寸看成一个确定已知的值，因为它的大小会随着不同机器不同而不同，所以这样的代码是不可移植的。</p>
<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h3><p>1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b=<span class="number">42</span>;      <span class="comment">//b 为true</span></span><br><span class="line"><span class="keyword">int</span>  i=b;       <span class="comment">//i的值=1</span></span><br><span class="line">i= <span class="number">3.14</span>;        <span class="comment">//correct</span></span><br><span class="line"><span class="keyword">double</span> pi=i;    <span class="comment">//pi=3.0;</span></span><br></pre></td></tr></table></figure>
<p>2）当我们赋给<strong>有符号</strong>类型一个超过它表示范围的值时候，结果是未定义的，这时程序可能继续工作，崩溃或者生成垃圾数据。</p>
<h4 id="3-1-无符号数"><a href="#3-1-无符号数" class="headerlink" title="3.1 无符号数"></a>3.1 无符号数</h4><!--3）当算术表达式中既有无符号数和int时，**int会转换成无符号数。此过程与把int直接赋值给无符号变量一样。**-->
<p>3）切勿混用有符号数和无符号数，因为<strong>有符号数会自动转换成无符号数。</strong></p>
<p>4）当从无符号数里减去一个数的时候，不管这个数是不是无符号数，<strong>都必须要确保结果不是一个负数</strong>。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unsinged u1=<span class="number">42</span>, u2=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; u1-u2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; u2-u1 &lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//正确，不过结果是4294967264。</span></span><br></pre></td></tr></table></figure>

<p>5）因为无符号数不会小于0，所以下面的程序会陷入死循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> u=<span class="number">0</span>;u&gt;=<span class="number">0</span>;--u)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; u &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;当u=0时，–u将不是-1而是4294967295（假设int类型占了32位）。</p>
<p>6）现代机器硬件在整型算术运算方面的设计中，是以补码模型设计的。按照这个角度来看，
无符号数和有符号数则只是对底层存储的解码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u1=<span class="number">10</span>,u2=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,u1-u2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1=<span class="number">10</span>,i2=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i1-i2);  <span class="comment">//i1-i2和上面的u1-u2的汇编代码本质上一样</span></span><br><span class="line">                       <span class="comment">//说明无符号数和有符号数在硬件层本质是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">i--;                    <span class="comment">//i的内存内容从0x00000000变成0xffffffff，表明是补码模型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u\n"</span>,i);       <span class="comment">//output: 4294967295</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);       <span class="comment">//output: -1</span></span><br><span class="line">                        <span class="comment">//同样的内存内容却输出不同的结果，表明有符号和无符号数</span></span><br><span class="line">                        <span class="comment">//只是更高层次的解码</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-字面值常量"><a href="#4-字面值常量" class="headerlink" title="4.字面值常量"></a>4.字面值常量</h3><h4 id="4-1-整型和浮点型字面值"><a href="#4-1-整型和浮点型字面值" class="headerlink" title="4.1 整型和浮点型字面值"></a>4.1 整型和浮点型字面值</h4><p>1）其数据类型由它的值和符号决定。它的类型是能容纳其数值的基本数据类型的尺寸最小者。</p>
<h4 id="4-2-字符和字符串字面值"><a href="#4-2-字符和字符串字面值" class="headerlink" title="4.2 字符和字符串字面值"></a>4.2 字符和字符串字面值</h4><p>2）指定字面值的类型
![string](/img/books/c++ primer/chapter2/string.png)</p>
<h3 id="5-普通变量"><a href="#5-普通变量" class="headerlink" title="5. 普通变量"></a>5. 普通变量</h3><h4 id="5-1-初始化"><a href="#5-1-初始化" class="headerlink" title="5.1 初始化"></a>5.1 初始化</h4><p>1） 初始化和赋值是两个完全不同的操作。初始化的含义是在创建变量时赋予一个初始值，而赋值的含义
是吧对象的当前值擦除，而以一个新值来替代。</p>
<p>2) 想定义一个名为units_sold的int变量并初始化为0，以下四条语句都可以做到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>花括号的初始形式给称为列表初始化。当用于内置类型的变量的初始化时，如果存在丢失信息的风险，编译器会报错。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b=&#123;ld&#125;;   <span class="comment">//wrong </span></span><br><span class="line">int c(ld), d=ld;     //right</span><br></pre></td></tr></table></figure>

<p>3) 定义于任何函数之外的内置类型变量被初始化为0。定义在函数体内的内置类型变量将不被初始化。</p>
<p>4）下面语句的extern会失效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//definition</span></span><br></pre></td></tr></table></figure>
<p>在函数内部试图初始化一个由extern关键字标记的变量，将引发错误。</p>
<h3 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h3><p>1）<strong>引用必须被初始化</strong>。在定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用。<strong>而且无法
让引用重新绑定给另外一个对象</strong>，因此必须初始化。</p>
<p>2）引用并非对象，所以不能定义引用的引用。</p>
<p>3） 除了const情况和另一种特殊情况，<strong>其他所有引用的类型都要和与之绑定的对象严格匹配</strong>。</p>
<h3 id="7-指针"><a href="#7-指针" class="headerlink" title="7.指针"></a>7.指针</h3><p>1） 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>2） 除了const情况和另一种特殊情况，<strong>其他所有指针的类型都要和与之绑定的对象严格匹配</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> * pd=&amp; dval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = pd ; <span class="comment">//wrong</span></span><br><span class="line">pi = &amp;dval;    <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>

<p>3） 把int变量直接赋值给指针是错误的，即使int变量正好等于0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> * pi =zero ;  <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>

<p>4) 指向指针的引用。</p>
<h3 id="8-const"><a href="#8-const" class="headerlink" title="8.const"></a>8.const</h3><p>1) 与引用的情况类似，const变量在创建后其值便不会再改变，所以const对象必须初始化。</p>
<p>2）默认情况下，const对象仅在文件内可见。如果想向其他文件共享一个const对象，无论声明和定义，const变量之前都要添加extern关键字。</p>
<p>3）const的引用被称为对常量的引用.</p>
<h4 id="8-1-const-引用"><a href="#8-1-const-引用" class="headerlink" title="8.1 const 引用"></a>8.1 const 引用</h4><p>4) 对应6-3），第一种例外情况就是<strong>在初始化常量引用时允许用任意表达式作为初始值，只要该表达式能够转换成引用的类型即可</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r2 = r1*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>; <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>
<p>其实，在这个过程中，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=dval;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; ri = temp;</span><br></pre></td></tr></table></figure>

<p>5) <strong>对const的引用可能引用一个并非const的对象</strong>。比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = i;</span><br></pre></td></tr></table></figure>
<p>这样的话，i的值是可以改变的，但不能通过r来改变i。</p>
<h4 id="8-2-const-指针"><a href="#8-2-const-指针" class="headerlink" title="8.2 const 指针"></a>8.2 const 指针</h4><p>6) 对应 7-2），const指针初始化时，允许一个指向常量的指针指向一个非常量对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * cptr= &amp;dval;</span><br></pre></td></tr></table></figure>
<p>可以换一种思路，<strong>所谓指向常量的指针或引用，不过是指针或者引用的自以为是，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值</strong>。</p>
<p>7) 当执行对象的拷贝时，顶层const不受什么影响，因为拷贝操作并不会改变被拷贝对象的值。但是，拷入和拷出的对象必须有相同的底层const资格，
或者两个数据类型可以转换。</p>
<h4 id="8-3-常量表达式"><a href="#8-3-常量表达式" class="headerlink" title="8.3 常量表达式"></a>8.3 常量表达式</h4><p>1） 常量表达式是指值不会改变并且<strong>在编译过程就能得到计算结果的表达式</strong>。C++ 11 允许将变量声明为constexpr类型以验证变量的值是否是一个常量表达式。
声明为constexpr的变量一定是一个常量，而且必须用常量初始化。</p>
<p>2） 如果用constexpr限制指针，constexpr只对指针有效，与指针所指的对象无关：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> * q = <span class="literal">nullptr</span> ; <span class="comment">//常量指针</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>c++ primer</tag>
      </tags>
  </entry>
</search>
